#!/bin/bash
#
# makesd
# partition and format an SD card suitable for GTA04 devices (Letux 2804 etc.)
# run this script on some host with a SD interface
# (c) Golden Delicious Comp. GmbH&Co. KG, 2014-2018
# Licenced under GPLv2
#

DEBUG=false
DRYRUN=false

[ "$VARIANT" ] || VARIANT=stable
[ "$ARCHITECTURE" ] || ARCHITECTURE=-armhf
[ "$DEV" ] || DEV="$(cat ~/.makesd.conf 2>/dev/null)"
[ "$DEV" ] || DEV=/dev/null	# no default set!
CMDLINE="DEV=$DEV $0 $@"		# save how makesd was called

function macros()
{
# format: macro-pattern macro-body
# it is valid to use shell variables in the body since they are expanded by the here-document
# $1 is expanded by the first argument given to the macros call
# patterns are regexp (expr : command)
# comments (lines starting with "#" can be used and they are ignored
# macros can be recursive

cat <<END
# basic macros
# boot loader
-bnone			$1
-bhttp://.*/.*		$1
-bhttps://.*/.*		$1
-b.*			http://download.goldelico.com/letux-u-boot/$1/u-boot.bin
-B.*			http://download.goldelico.com/letux-u-boot/$1
# kernel
-knone			$1
-khttp://.*/.*		$1
-khttps://.*/.*		$1
-k.*			http://download.goldelico.com/letux-kernel/$1/uImage
# device tree
-dnone			$1
-dhttp://.*/.*		$1
-dhttps://.*/.*		$1
-d.*			http://download.goldelico.com/letux-kernel/$1/device-trees.tbz
# kernel modules
-mnone			$1
-mhttp://.*/.*		$1
-mhttps://.*/.*		$1
-m.*			http://download.goldelico.com/letux-kernel/$1/modules.tgz
# additional config
-cnone			$1
-chttp://.*/.*		$1
-chttps://.*/.*		$1
-c.*			http://download.goldelico.com/letux-debian-rootfs/$1-config.tgz
# rootfs
-rnone			$1
-rhttp://.*/.*		$1
-rhttps://.*/.*		$1
-rdebian		http://download.goldelico.com/letux-debian-rootfs/$VARIANT$ARCHITECTURE-minimal.tbz
-rlxde			http://download.goldelico.com/letux-debian-rootfs/$VARIANT$ARCHITECTURE-lxde.tbz
-rxfce			http://download.goldelico.com/letux-debian-rootfs/$VARIANT$ARCHITECTURE-xfce4.tbz
-rqtmoko		http://download.goldelico.com/letux-debian-rootfs/$VARIANT$ARCHITECTURE-qtmoko.tbz
-rreplicant		http://download.goldelico.com/letux-replicant/4.2/$VARIANT-replicant.tbz
-rpyraos		http://download.goldelico.com/letux-debian-rootfs/$VARIANT$ARCHITECTURE-pyraos.tbz
-re17			http://download.goldelico.com/letux-debian-rootfs/$VARIANT$ARCHITECTURE-e17.tbz
-rquantumstep		http://download.goldelico.com/letux-debian-rootfs/$VARIANT$ARCHITECTURE-quantumstep.tbz
-rphosh			http://download.goldelico.com/letux-debian-rootfs/$VARIANT$ARCHITECTURE-phosh.tbz
# single partition file system(s) - should boot if boot loader is in flash/eMMC
debian			-f ext4 -r debian -kboot $VARIANT -dboot $VARIANT -m $VARIANT -I
lxde			debian -r lxde
xfce			debian -r xfce
quantumstep		debian -r quantumstep
qtmoko			debian -r qtmoko
replicant		debian -k none -d none -m none -r replicant
pyraos			debian -r pyraos
phosh			debian -r phosh
all 			lxde qtmoko replicant quantumstep
all2 			xfce qtmoko phosh quantumstep
# production images (dual partition) for specific devices
gta04			-f fat -s 5 -b GTA04/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
l2804			gta04
gta04one		-f fat -s 5 -b GTA04-OneNAND/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
gta04a5			gta04one
l2804a5			gta04one
gta04b2			-f fat -s 5 -b Letux-3704/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
l3704			gta04b2
gta04b3			-f fat -s 5 -b Letux-7004/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
l7004			gta04b3
gta04b7			-f fat -s 5 -b Neo900/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
neo900			gta04b7
bb			-f fat -s 5 -b Letux-BeagleBoard/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
beagleboard		bb
bbb			-f fat -s 5 -b Letux-BeagleBone-Black/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
lc8			-f fat -s 5 -b Letux-Cortex-8/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
pocketbeagle		lc8
bb+b1			-f fat -s 5 -b OpenMoko-Beagle-Hybrid/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
bb+b2			-f fat -s 5 -b Openmoko-Beagle-Hybrid-b2/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
bb+b4			-f fat -s 5 -b Openmoko-Beagle-Hybrid-b4/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
bb+b7			-f fat -s 5 -b BeagleBoard-Neo900/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
panda-es		-f fat -s 5 -b PandaBoard-ES/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
omap5432evm		-f fat -s 5 -b OMAP5-uEVM/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
omap5432evm+pyra	-f fat -s 5 -b OMAP5-uEVM+Pyra4.9/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
pyra+lc15		-f fat -s 5 -b Pyra+LC15/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
pyra+lc15-4.9		-f fat -s 5 -b Pyra+LC15-4.9/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
pyra+lc15-4gb		-f fat -s 5 -b Pyra+LC15-4GB/$VARIANT -k $VARIANT-lpae -d $VARIANT-lpae lxde -m $VARIANT-lpae -k none -d none -s 95
pyra			pyra+lc15 -r pyraos
pyra-lxde		pyra+lc15 -r lxde
pyra-4gb		pyra+lc15-4gb -r pyraos
lc15			-f fat -s 5 -b Letux-Cortex-15/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
lc15-4.9		-f fat -s 5 -b Letux-Cortex-15-4.9/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
lc15-4gb		-f fat -s 5 -b Letux-Cortex-15-4GB/$VARIANT -k $VARIANT-lpae -d $VARIANT-lpae lxde -k none -d none -m $VARIANT-lpae -s 95
lc15evm			-f fat -s 5 -b Letux-Cortex-15-EVM/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
lc15evm-4gb		-f fat -s 5 -b Letux-Cortex-15-EVM-4GB/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
gta15			-f fat -s 5 -b GTA15/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
gta15-4gb		-f fat -s 5 -b GTA15-4GB/$VARIANT -k $VARIANT -d $VARIANT lxde -k none -d none -s 95
pyraphone		gta15
# for Pandora, a single partition image can boot
openpandora		lxde -b OpenPandora/$VARIANT
pandora			openpandora
# Udoo Neo needs a pseudo-single-partition but SPL and u-boot must be copied by dd
udoo-neo		-p 2 -dd Udoo-Neo/$VARIANT/SPL -p 138 -dd Udoo-Neo/$VARIANT/u-boot.img -p 2048 lxde -bboot Udoo-Neo/$VARIANT -kboot $VARIANT -dboot $VARIANT -m $VARIANT
# Raspi 3B+ needs special setup with bootloader and boot plus rootfs partitions
raspi3b+		-f fat -s 5 -I -x https://github.com/raspberrypi/firmware/raw/master/boot/bootcode.bin \
			-x https://github.com/raspberrypi/firmware/raw/master/boot/fixup.dat \
			-x https://github.com/raspberrypi/firmware/raw/master/boot/start.elf \
			-x http://download.goldelico.com/letux-u-boot/RasPi-3B+/$VARIANT/config.txt \
			-x http://download.goldelico.com/letux-u-boot/RasPi-3B+/$VARIANT/cmdline.txt \
			-k http://download.goldelico.com/letux-kernel/$VARIANT/zImage -d $VARIANT lxde -k none -d none -m $VARIANT -s 95
# we must make sure that we load the mipsel variants and not armel/armhf
lenny400		-A mipsel -f fat -s 2 -k http://download.goldelico.com/letux-400/20110208-lenny400/uImage -f ext -r http://download.goldelico.com/letux-400/20110208-lenny400/bootstrapped-rootfs.tbz -m http://download.goldelico.com/letux-400/20110208-lenny400/modules.tgz
mipsbook-400		-A mipsel -f fat -s 2 -k $VARIANT-l400 -d $VARIANT-l400 -f ext -r http://download.goldelico.com/letux-400/20110208-lenny400/bootstrapped-rootfs.tbz -m $VARIANT-l400
mipsbook		mipsbook-400
letux-400		mipsbook-400
# Imagination CI20 needs a pseudo-single -partition but SPL and u-boot must be copied by dd
# see https://elinux.org/CI20_Dev_Zone#Making_a_bootable_SD_card_from_sources
ci20			-p 1 -dd CI20/$VARIANT/u-boot-spl.bin -p 28 -dd CI20/$VARIANT/u-boot.img -p 4096 -A mipsel lxde -bboot CI20/$VARIANT -kboot $VARIANT-l400 -dboot $VARIANT-l400 -m $VARIANT-l400
# Kobo Clara / Tolino Shine 3 needs a pseudo-single-partition but SPL and u-boot must be copied by dd
clara			-p 2 -dd Clara/2019-09-09/boot -p 2 -dd Clara/$VARIANT/u-boot.imx -p 1536 -dd Clara/$VARIANT/clara-env.bin -p 49152 debian -I -kboot $VARIANT -dboot $VARIANT -m $VARIANT
e60k02-kobo		clara
shine3			clara -p 2 -dd Shine3/$VARIANT/u-boot.imx -p 1536 -dd Shine3/2019-10-05/shine3-env.bin
e60k02-tolino		tolino3
			# pinephone should use -A arm64 in the future but it also boots with armhf
pinephone		-p 1 -dd PinePhone/2019-12-20/u-boot-spl.bin -p 1953 -A armhf lxde -bboot PinePhone/$VARIANT -kboot http://download.goldelico.com/letux-kernel/$VARIANT-arm64/Image.gz -dboot $VARIANT-arm64 -m $VARIANT-arm64
END
}

function lookup()
{
	# "$1" is key
	# returns expanded macro or empty string if not found
	# pass our $1 after stripping -? to $1 within here-document
	local MACRO COMMAND
	macros $(expr "$1" : "-.\(.*\)") | {
		while read MACRO COMMAND
		do
			case "$MACRO" in
				'' | '#' | '#'* )
					continue;;
				* )
					if expr "$1" : "^$MACRO\$" >/dev/null
						then # found
						$DEBUG && echo "$1" matches "$MACRO -> $COMMAND" >&2
						echo "$COMMAND"
						return
					fi
			esac
			done
			$DEBUG && echo "$1" no match >&2
			echo ""
		}
}

function useage()
{

## fixme: list available macros separately

	cat <<END
useage: [DEV=/dev/device] makesd [--dry --debug --help -- update] [partition1 [partition2 [partition3 [partition4]]]]"

  DEV=/dev/device - specify the raw device (not the partitions), e.g. /dev/sdc
                    alternatively echo to ~/.makesd.conf
  general options:

    --debug -- print internal activities and status
    --dry -- dry run (don't touch SD card)
    --help -- print this help
    -i | --no-format -- install only
    -u | --update -- selfudate
    -a -- list all macros

  partition:
    format (starts next partition):
    -f fat
    -f ext3
    -f ext4
    -f none
    -f[0-4]	switch to given partition - note that another -f will increment by 1
    -f-		go back one partition so that we can specify a macro that contains a -f
    -F		go back one partition so that we can specify a macro that contains a -f
    -s size	define relative size (do not specify a % suffix or other units!)
    -p sector	position start of next partition (-f) or -dd to a specific sector (512 byte / sector)
    low level copy:
    -x[dirfile] <url>	raw expand of remote file into directory dir or file (trying different suffixes like .tar, .tbz)
		[can be specified multiple times]
    -dd <url>	copy binary file to current position (as defined by -p)
		[can be specified multiple times]
    -I		write makesd.info to current partition - should be used if there is no -b
    bootloader:
    -b[dir] <url>
    -b[dir] version
    -b none
    device tree files:
    -d[dir] <url>
    -d[dir] version
    -d none
    kernel:
    -k[dir] <url>
    -k[dir] version
    -k none
    modules:
    -m version
    -m none
    config patches:
    -c <url>
    -c none
    root file system (OS):
    -r <url>
    -r none
    -r debian
    -r lxde
    -r quantumstep
    -r replicant
    -r qtmoko
    -r pyraos
    -v variant -- choose different variant for -r and many macros (default is 'stable')
    -A architecture -- choose different architecture variant

    macros for single partition cards:
      lxde = -f ext4 -r lxde -d all -k \$VARIANT -m \$VARIANT -c \$VARIANT
      qtmoko = -f ext4 -r qtmoko -d all -k \$VARIANT (does not need config)
      replicant = -f ext4 -d all -r replicant-4.2 (has its own kernel)
      quantumstep = -f ext4 -r quantumstep -d all -k \$VARIANT -m \$VARIANT -c \$VARIANT

    macros for multiple partitions (to create bootable production image SD card):
      gta04 | l2804 = -f fat -b \$VARIANT lxde
      gta04one | gta04a5 = -f fat -b \$VARIANT/GTA04A5 lxde
      gta04b2 | l3704 = -f fat -b \$VARIANT/b2 lxde
      gta04b3 | l7004 = -f fat -b \$VARIANT/b3 lxde
      gta04b7 | neo900 = -f fat -b \$VARIANT/b7 lxde
      bb = -f fat -b \$VARIANT/ beagleboard lxde
      bbb = -f fat -b \$VARIANT/ beagleboardblack lxde
      panda-es = -f fat -b \$VARIANT/panda-es lxde
      pyraos = -f fat -b \$VARIANT/ pyra pyraos
      openpandora = -f fat -b \$VARIANT/ openpandora lxde
      all = lxde qtmoko replicant quantumstep

examples:"
  makesd -- makes a single-partition LXDE image
  makesd lxde -- also makes a LXDE image
  makesd replicant -- makes a single partition replicant image
  makesd all -- makes a 4-partition card
  makesd gta04 -- makes the stable production (recovery) image for the GTA04 (includes boot loader)
  makesd gta04 -f1 -b GTA04/2015-10-25 -- makes the \$VARIANT image for the GTA04 but use U-Boot from 2015-10-25
  makesd gta04 -d letux-4.10.4 -k letux-4.10.4 -m letux-4.10.4 -- replace DT, kernel and modules by specific version
  makesd pyra -r http://download.goldelico.com/letux-debian-rootfs/stable-pyraos.tbz -- install stable PyraOS
  makesd -v unstable gta04 -- makes an unstable production image
  makesd -v unstable gta04 -f1 quantumstep -- makes an unstable production image but with quantumstep rootfs
  makesd -v 20141006-GTA04-beta-3.17.0-wheezy-7.6 l3704 -- makes the specified version for the Letux 3704
  DEV=/dev/sdd makesd --dry -- does a dry run on /dev/sdd
  makesd -u -- self-update
  DEV=/dev/sdd makesd omap5432evm -f1 -b OMAP5432-uEVM/2016-05-10 -k letux-4.8-rc6 -d letux-4.8-rc6 -f2 -m letux-4.8-rc6 xfce
  DEV=/dev/sdb makesd pyra -f1 -k letux-4.11-rc4 -d letux-4.11-rc4 -v 20170401-jessie-8.7 lxde -m letux-4.11-rc4

END
}

function setparam()
{ # $partition $name $value
	if [ "(" "$1" -lt 1 -o "$1" -gt 4 ")" ]
		then
		echo "invalid partition number $1" >&2
		useage
		exit 1
	fi
	$DEBUG && echo setparam $1 $2 $3
	eval $2$1="'$3'"
}

function getparam()
{ # $partition $name
	eval echo \"\$$2$1\"
}

DDLIST=""
XLIST=""

function process()
{ # $1 .. $n
	while [ "$1" ]
		do
		case "$1" in
			-f[0-4] ) # switch to given partition (but don't change type)
				NP=$(expr "$1" : "-f\(.*\)" )
				# FIXME: check type!
				$DEBUG && echo "switched to partition $NP" >&2
				;;
			-F | -f- ) # switch to previous partition
				NP=$(expr "$NP" - 1)
				if [ "$NP" -lt 0 ]
				then
					echo "can't go back that far" >&2
					useage
					exit 1
				fi
				;;
			-f ) # switch to next partition
				NP=$(expr "$NP" + 1)
				if [ "$NP" -gt 4 ]
				then
					echo "too many partitions specified (max. 4)" >&2
					useage
					exit 1
				fi
				shift
				setparam $NP FORMAT "$1"
				setparam $NP SIZE "25"
				setparam $NP PSTART "$PSTART"
				PSTART=""
				if [ "$1" = "none" ]
					then # don't install anything
					setparam $NP BOOT "none"
					setparam $NP KERNEL "none"
					setparam $NP MODULES "none"
					setparam $NP DT "none"
					setparam $NP ROOTFS "none"
					setparam $NP CONFIG "none"
				fi
				;;
			-s ) # define relative size (typically in %)
				shift
				setparam $NP SIZE "$1"
				;;
			-p ) # define partition or dd start sector (must come before -f or -p)
				shift
				PSTART="$1"
				;;
			-I* )	# write info
				# should we allow a subdirectory?
				setparam $NP INFO "true"
				;;
			-dd )	# copy (raw) file to current partition start
				shift
				if ! [ "$PSTART" ]
				then
					echo "missing partition start (-p sector)" >&2
					useage
					exit 1
				fi
				case "$1" in
					http://* | https://* | file:* )
						local F="$1"
						;;
					* ) # relative to boot directory
						local F=$(lookup "-B$1")
						;;
				esac
				if [ "$DDLIST" ]
				then DDLIST="$DDLIST
$PSTART $F"	# append new line
				else DDLIST="$PSTART $F"	# first line
				fi
				;;
			-x* )	# low level extract of url file/package into given directory/file
				local SUBDIR=${1:2}
				[ "$SUBDIR" ] || SUBDIR=/
				SUBDIR=$(echo "$SUBDIR" | sed 's|\.\./||g')	# protect - not perfect - .../file -> .file
				shift
				local XLIST="$(getparam $NP XLIST)"
				if [ "$XLIST" ]
				then XLIST="$XLIST
$SUBDIR $1"	# append new line
				else XLIST="$SUBDIR $1"	# first line
				fi
				setparam $NP XLIST "$XLIST"
				;;
			-b* ) # define boot loader
				setparam $NP BOOTDIR "$(expr "$1" : "-b\(.*\)")"
				shift
				$DEBUG && echo "bootloader $1" >&2
				local P=$(lookup "-b$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP BOOT "$P"
				;;
			-k* ) # define kernel
				setparam $NP KERNELDIR "$(expr "$1" : "-k\(.*\)")"
				shift
				$DEBUG && echo "kernel $1" >&2
				local P=$(lookup "-k$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP KERNEL "$P"
				;;
			-m ) # define modules
				shift
				$DEBUG && echo "modules $1" >&2
				local P=$(lookup "-m$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP MODULES "$P"
				;;
			-d* ) # define device trees
				setparam $NP DTDIR "$(expr "$1" : "-d\(.*\)")"
				shift
				$DEBUG && echo "device trees $1" >&2
				local P=$(lookup "-d$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP DT "$P"
				;;
			-r ) # define root file system
				shift
				$DEBUG && echo "rootfs $1" >&2
				local P=$(lookup "-r$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP ROOTFS "$P"
				;;
			-c ) # define additional config
				shift
				$DEBUG && echo "config $1" >&2
				local P=$(lookup "-c$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP CONFIG "$P"
				;;
			-v ) # define variant
				shift
				$DEBUG && echo "variant $1" >&2
				[ "$1" ] && VARIANT="$1"	# overwrite
				;;
			-A ) # define architecture
				shift
				$DEBUG && echo "architecture $1" >&2
				[ "$1" ] && ARCHITECTURE="-$1"	# overwrite with hyphen prefix
				;;

			-* )
				echo "unknown option: $1" >&2; useage >&2; exit 1
				;;
			* )
				local COMMAND=$(lookup "$1")
				if [ "$COMMAND" ]
				then
					process $COMMAND
				else
					echo "unknown macro: $1" >&2; useage >&2; exit 1
				fi
				;;
		esac
		shift
	done
}

function exists()
{ # check if tool exists
	which "$1" >/dev/null
}

function fetch()
{ # $url $dest - make sure that $dest exists only on success
	$DEBUG && echo "-- fetch $1 $2 --" >&2
	if $DRYRUN
	then
		echo "fetch $1 -> $2" >&2
	elif [ ${1:0:5} = "file:" ]
	then # file: pattern
		local _FILE=${1#"file:"}
		if [ "$2" = "-" ]
		then # to stdout
			$DEBUG && echo "-- cat $_FILE --" >&2
			cat $_FILE
		else
			$DEBUG && echo "-- cp $_FILE $2 --" >&2
			cp $_FILE $2 || rm "$2"
		fi
	elif exists wget
	then # wget exists
		if [ "$2" = "-" ]
		then # to stdout
			$DEBUG && echo "-- wget -O - $1 --" >&2
			wget -O - "$1"
		else
			$DEBUG && echo "-- wget -O - $1 >$2 --" >&2
			wget -O - "$1" >"$2" || rm "$2"
		fi
	elif exists curl
	then # try curl
		if [ "$2" = "-" ]
		then # to stdout
			$DEBUG && echo "-- curl $1 --" >&2
			curl "$1"
		else
			$DEBUG && echo "-- curl $1 -o $2 --" >&2
			curl "$1" -o "$2" || rm "$2"
		fi
	else
		echo "error: can't fetch files (please install 'wget' or 'curl')" >&2
		exit 1
	fi
}

function partitions()
{ # print partition table
	local P
	if [ "$DDLIST" ]
	then
		echo "$DDLIST" | while read SECTOR FILE
		do
			[ "$SECTOR" ] && echo "-: s:$SECTOR dd:$FILE"
		done
	fi
	for P in 1 2 3 4
	do
		FORMAT="$(getparam "$P" FORMAT)"
		SIZE="$(getparam "$P" SIZE)"
		[ "$FORMAT" = none ] && SIZE=0
		BOOT="$(getparam "$P" BOOT)"
		[ "$BOOT" != none ] && BOOT="$(dirname "$BOOT")/*" # remove u-boot.bin and replace
		BOOTDIR=/"$(getparam "$P" BOOTDIR)"
		KERNEL="$(getparam "$P" KERNEL)"
		KERNELDIR="/$(getparam "$P" KERNELDIR)"
		DT="$(getparam "$P" DT)"
		DTDIR="/$(getparam "$P" DTDIR)"
		ROOTFS="$(getparam "$P" ROOTFS)"
		MODULES="$(getparam "$P" MODULES)"
		CONFIG="$(getparam "$P" CONFIG)"
		echo "$P: $FORMAT $SIZE% b:$BOOTDIR+$BOOT k:$KERNELDIR+$KERNEL dt:$DTDIR+$DT r:$ROOTFS m:$MODULES c:$CONFIG"
		XLIST="$(getparam "$P" XLIST)"
		[ "$XLIST" ] && echo "$P: x:$(echo $XLIST)"
	done
}

# https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash
function version
{
	printf "%03d%03d%03d%03d" $(echo "$1" | tr '.' ' ')
}

function sane_sfdisk {
	SFVER=$(sfdisk -v | awk '{print $4}')
# echo sfdisk version: $SFVER $(version $SFVER) >&2
	if [ "$(version $SFVER)" -ge "$(version 2.26)" ]
	then
		# 2.26.2 and later have changed API
		# compare to http://linux-sunxi.org/Bootable_SD_card#Partitioning
		# -L		is deprecated and default
		# -uS		is default now and deprecated
		# --in-order	is gone and default
		# -R		is removed
		sfdisk "$@"
	else
		sfdisk --in-order --Linux -uS "$@"
	fi
}

function disk_size {
	# make sure fdisk runs in default LANGUAGE
	( export LC_ALL=C LANGUAGE=C; fdisk -l "$1" ) | fgrep " $1: " | head -1 | awk '{print $5}'
	# expr 1024 '*' $(sane_sfdisk -s "$DEV")	# total size in bytes - but why 1024? is this well defined?
}

### here starts real processing ###

for TOOL in sfdisk fdisk partprobe dd mkfs.vfat mke2fs fsck.vfat fsck.ext3 fsck wget bzip2 tar
do
	[ $(which $TOOL) ] || { echo "please install '$TOOL' (apt-get install util-linux)" >&2; exit 1; }
done

setparam 2 KERNEL 1234
_TESTME=$(getparam 2 KERNEL)
if [ "$_TESTME" != 1234 ]
then
	echo "error: getparam and setparam did not pass internal test - please check shell or script" >&2
	set
	exit
fi
unset _TESTME

while [ "$1" ]
do
	case "$1" in
		"-a" )	# list all macros
		macros | while read MACRO COMMAND
				do
				case "$MACRO" in
					'' | '#' | '#'* )	continue;;	# comment
					-* | '*' )		continue;;	# pattern
					* )			echo "$MACRO";;
				esac
			done | sort
			exit
			;;
		"-i" | "--no-format" )
			NOFORMAT=yes
			;;
		"-u" | "--update" )	# self-update
			$DEBUG && echo "-- self-update --" >&2
			fetch "http://git.goldelico.com/?p=gta04-makesd.git;a=blob_plain;hb=HEAD;f=$(basename $0)" "$0.new" &&
			chmod +x $0.new &&
			mv $0.new $0
			exit
			;;
		"--debug" )
			DEBUG=true
			;;
		"--dry" )
			DRYRUN=true
			;;
		"--help" )
			useage
			exit
			;;
		* )
			break
			;;
	esac
	shift
done

$DEBUG && echo "-- define defaults --" >&2
NP=0
process -f none -f none -f none -f none

if [ "$1" ]
then
	$DEBUG && echo "-- start over with given options --" >&2
	# start over with given options
	NP=0
	process "$@" || exit 1
fi

partitions

$DEBUG && echo "-- prepare $DEV --" >&2

if [ "${DEV}" = "/dev/sda" ]
then
	echo "error: refuses to overwrite /dev/sda" >&2
	exit 1
fi

if ! [ -b "$DEV" ] && ! $DRYRUN
then
	echo "error: not a block device: $DEV" >&2
	echo "  either edit echo /dev/device > ~/.makesd.conf" >&2
	echo "  or pass DEV=/dev/device" >&2
	exit 1
fi

if ! [ -w "$DEV" ] && ! $DRYRUN
then
	echo "error: you do not have write permission for: $DEV" >&2
	echo "Maybe you should run as root - but beware you may loose all data if you choose the wrong device!" >&2
	exit 1
fi

DEVP=$DEV
if [ -b "${DEV}p1" ] || expr "${DEV}" : "/dev/mmc.*" >/dev/null
then
	DEVP=${DEV}p	# MMC card reader expects "p"artition suffix (hard coded into kernel)
	$DEBUG && echo "-- suffix p added --" >&2
fi

$DEBUG && echo "-- unmount partitions --" >&2

function totalsize()
{ # also create mount points!
local P
TOTALSIZE=0
for P in 1 2 3 4
do
	umount -f ${DEVP}${P} 2>/dev/null
	wait
	case "$(getparam $P FORMAT)" in
		none )
			## check if this is the last or only followed by "none"
			## i.e. there can't be "holes" in the partition numbers
			;; # skip
		fat | ext* | swap )
			! $DRYRUN && mkdir -p /media/P${P}
			TOTALSIZE=$(expr "$TOTALSIZE" + "$(getparam $P SIZE)")	# sum up
			;;
		* )
			echo "error: invalid partition type '$(getparam $P FORMAT)' for partition $P" >&2
			exit 1
			;;
	esac
done
}

# make sure we are not mounted anywhere else
umount ${DEV}*
sleep 2
umount ${DEV}*

totalsize

ls -l /media/P[1-4]

$DEBUG && echo "-- total size $TOTALSIZE --" >&2

if ! [ "$NOFORMAT" ]
then

$DEBUG && echo "-- clear boot record --" >&2
if ! $DRYRUN
then
	dd if=/dev/zero of=$DEV bs=1024 count=1024	# clear boot records
	dd if=/dev/urandom bs=1 count=4 seek=440 of=$DEV	# write a fresh random unique disk identifier (MBR)
fi

## the following code is roughly
## based on: http://omappedia.org/wiki/SD_Configuration#Script_to_partition.2Fformat_SDCards
## and: http://www.sakoman.com/OMAP/a-script-for-partitioningformatting-a-bootable-sdmicrosd-card.html

$DEBUG && echo "-- partitioning --" >&2

function sfdisk_table()
{ # run in an anonymous function, not a subprocess
TS=$TOTALSIZE	# save for next call
SIZE=$(disk_size "$DEV")
$DEBUG && echo "-- DISK SIZE: $SIZE bytes --" >&2
[ "$SIZE" ] || { echo "error: can't determine size of disk $DEV" >&2; exit 1; }
TOTALSECTORS=$(expr "$SIZE" / 512)
$DEBUG && echo "-- TOTAL SECTORS: $TOTALSECTORS --" >&2
SECTORS=63
HEADS=255
CYLINDERS=$(expr "$TOTALSECTORS" / "$HEADS" / "$SECTORS")
$DEBUG && echo "-- CYLINDERS: $CYLINDERS --" >&2
SECTORSPERCYLINDER=$(expr "$TOTALSECTORS" / "$CYLINDERS")
$DEBUG && echo "-- SECTORS PER CYLINDER: $SECTORSPERCYLINDER --" >&2
PSTART=128
local P
for P in 1 2 3 4
do # calculate sizes of partitions
	FORMAT=$(getparam $P FORMAT)
	PS=$(getparam $P PSTART)
	[ "$PS" ] || PS=$PSTART
	REMAINING=$(expr "$TOTALSECTORS" - "$PS")
	THISSIZE=$(getparam $P SIZE)
	[ "$FORMAT" = none ] && THISSIZE=0	# overwrite (has not been counted for TOTALSIZE)
	if [ "$THISSIZE" = "$TOTALSIZE" ]
	then # last partition
		PSECTORS="$REMAINING"	# take all remaining sectors
	elif [ "$TOTALSIZE" -gt 0 ]
	then # intermediate partition
		PE=$(getparam $(expr $P + 1) PSTART)
		if [ "$PE" ]
		then # next sector has specified explicit start
			PSECTORS=$(expr "$PE" - "$PSTART")
		else
			PSECTORS=$(expr \( "$REMAINING" '*' "$THISSIZE" \) / "$TOTALSIZE")
		fi
#		S1=$PSECTORS
#		echo "S1: $S1" >&2
#		S2=$(expr "$PSTART" + "$S1" + "$SECTORSPERCYLINDER" - 1 )
#		echo "S2: $S2" >&2
#		S3=$(expr "$S2" / "$SECTORSPERCYLINDER" )
#		echo "S3: $S3" >&2
#		PSECTORS=$(expr \( \( "$PSTART" + "$PSECTORS" + "$SECTORSPERCYLINDER" - 1 \) / "$SECTORSPERCYLINDER" \) "*" "$SECTORSPERCYLINDER" - "$PSTART") # round up to end of full cylinder boundary
	else
		PSECTORS=0	# must be a "none"
	fi
	TOTALSIZE=$(expr "$TOTALSIZE" - "$THISSIZE")	# this is not exactly correct
	PSTART=$(expr "$PS" + "$PSECTORS")	# calculated start of next partition
if $DEBUG
then
	echo "P: $P" >&2
	echo "PSTART: $(getparam $P PSTART)" >&2
	echo "FORMAT: $FORMAT" >&2
	echo "REMAINING: $REMAINING" >&2
	echo "THISSIZE: $THISSIZE ($TOTALSIZE)" >&2
	echo "SECTORS: $PS + $PSECTORS .. $PSTART" >&2
fi
	# FIXME: use "Named-fields format" to specify data for a specific partition
	# e.g. $P: start=$PS,size=$PSECTORS,type=0c,bootable
	# e.g. $P: start=$PS,size=$PSECTORS,type=83
	# but sfdisk in Debian Jessie does not yet understand
	case "$FORMAT" in
		none )
			: skip # (how with sfdisk? do we have to read the current partition sizes)
			# this gives the wrong impression that we could define just a partition 3 and none for 1 & 2
			# in other words: there should only be "none" records after the first "none"
			# but we don't check that yet
			SFVER=$(sfdisk -v | awk '{print $4}')
			if [ "$(version $SFVER)" -lt "$(version 2.26)" ]
			then
				echo "$PS,0,0,-"	# empty partition
			fi
			;;
		fat )
			# echo "$P: start=$PSTART,size=$PSECTORS,type=0c,bootable"	# FAT partition (bootable)
			echo "$PS,$PSECTORS,0x0C,*"	# FAT partition (bootable)
			;;
		ext* )
			# echo "$P: start=$PSTART,size=$PSECTORS,type=83"	# Linux partition
			echo "$PS,$PSECTORS,83,-"	# Linux partition
			;;
		swap )
			## echo "$P: start=$PSTART,size=$PSECTORS,type=82"	# Linux swap partition
			echo "$PS,$PSECTORS,82,-"	# Linux swap partition
			;;
	esac
done
if [ "$TOTALSIZE" != 0 -o "$REMAINING" != 0 ]
	then
	echo "error: error in partition calculation" >&2
	echo "TOTALSIZE: $TOTALSIZE" >&2
	echo "REMAINING: $REMAINING" >&2
	echo "did yo specify 4 empty partitions?" >&2
	exit 1
fi
TOTALSIZE=$TS	# restore for next call
}

if $DRYRUN
then
	sfdisk_table >&2
else
	$DEBUG && sfdisk_table >&2
	sfdisk_table | sane_sfdisk --force "$DEV" || exit
	sleep 2
	# this may try to remount!
	[ -x /sbin/partprobe ] && /sbin/partprobe "$DEV"
	# alternative? blockdev --rereadpt "$DEV"
	sleep 2
fi

# fdisk -l "$DEV"

$DEBUG && echo "-- format partitions --" >&2

fi	# ! NOFORMAT

FATNUM=""
EXTNUM=""

for P in 1 2 3 4
do # format and mount partitions
	if $DRYRUN
	then
		$DEBUG && echo "-- format ${DEVP}${P} as $(getparam $P FORMAT) --" >&2
		continue
	fi
	umount ${DEVP}${P} 2>/dev/null
	sleep 1
	case "$(getparam $P FORMAT)" in
		none )
			: skip
			;;
		fat )
			if ! [ "$NOFORMAT" ]
			then
				PNAME="boot$FATNUM"
				FATNUM=$(expr "${FATNUM:=1}" + 1)	# first has no suffix, second gets suffix "2"
				echo making $(getparam $P FORMAT) partition $PNAME
				mkfs.vfat -F 32 -n $PNAME ${DEVP}${P} &&
				fsck.vfat -a -y ${DEVP}${P}
			fi
			mount ${DEVP}${P} /media/P${P} || exit
			;;
		ext* )
			if ! [ "$NOFORMAT" ]
			then
				PNAME="rootfs$EXTNUM"
				EXTNUM=$(expr "${EXTNUM:=1}" + 1)	# first has no suffix, second gets suffix "2"
				echo making $(getparam $P FORMAT) partition $PNAME
				yes | mke2fs -j -L "${PNAME}" ${DEVP}${P} &&
				fsck.ext3 -y ${DEVP}${P}
			fi
			mount ${DEVP}${P} /media/P${P} || exit
			;;
		swap )
			mkswap -L "swap$P" ${DEVP}${P}
			;;
	esac
done

df # should have been formatted and mounted now

$DEBUG && echo "-- variables --" >&2
$DEBUG && set >&2

$DEBUG && echo "-- install --" >&2

KERNEL_VERSION=""

$DEBUG && echo "-- process -dd --" >&2
if [ "$DDLIST" ]
then
	echo "$DDLIST" | while read SECTOR FILE
		do
		if [ "$SECTOR" ]
		then
			$DEBUG && echo "-- fetch $FILE to sector $SECTOR --" >&2
			! $DRYRUN && fetch "$FILE" - | dd of=$DEV bs=512 seek=$SECTOR
		fi
		done
fi

for P in 1 2 3 4
do

FORMAT=$(getparam "$P" FORMAT)
$DEBUG && echo "-- process partition $P with format $FORMAT --" >&2

if [ "$FORMAT" = "none" -o "$FORMAT" = "swap" ]
then
	continue	# skip
fi

if [ ! -d /media/P${P} ]
then
	echo "-- partition /media/P${P} not mounted --" >&2
fi

ROOTFS=$(getparam "$P" ROOTFS)
if [ "$ROOTFS" != none ]
then # a rootfs must be installed first so that we can overwrite by a kernel

	$DEBUG && echo "-- fetch rootfs to /media/P${P} --" >&2
	ls -l /media/P${P}
	# run in a subshell so that we can really redirect ouput
	case "$ROOTFS" in
	*.tgz ) fetch "$ROOTFS" - | ( cd "/media/P${P}" && tar xvzf - --numeric-owner ) ;;
	*.tbz ) fetch "$ROOTFS" - | ( cd "/media/P${P}" && tar xvjf - --numeric-owner ) ;;
	* )	echo "-- don't know how to unpack $ROOTFS --" >&2; exit ;;
	esac
fi

BOOT=$(getparam "$P" BOOT)
BOOTDIR="/media/P${P}/$(getparam "$P" BOOTDIR)/"
if [ "$BOOT" != none ]
then
	$DEBUG && echo "-- fetch boot loader to $BOOTDIR --" >&2
	mkdir -p "$BOOTDIR" || exit
	#
	# loading some files may fail since they do not exist for the chosen variant - but we ignore
	#
	fetch "$(dirname "$BOOT")/MLO" "$BOOTDIR/MLO"	# must come first
	fetch "$(dirname "$BOOT")/x-load.flash" "$BOOTDIR/x-load.flash"
	fetch "$(dirname "$BOOT")/MLO.flash" "$BOOTDIR/MLO.flash"
	fetch "$BOOT" "$BOOTDIR/u-boot.bin"
	fetch "$(dirname "$BOOT")/u-boot.img" "$BOOTDIR/u-boot.img"	# some x-loaders want u-boot.bin others want u-boot.img (e.g. the OMAP5 MLO)
	fetch "$(dirname "$BOOT")/u-boot.flash" "$BOOTDIR/u-boot.flash"
	fetch "$(dirname "$BOOT")/u-boot.img.flash" "$BOOTDIR/u-boot.img.flash"
	fetch "$(dirname "$BOOT")/splash.rgb16z" "$BOOTDIR/splash.rgb16z"
	fetch "$(dirname "$BOOT")/menu.rgb16z" "$BOOTDIR/menu.rgb16z"
	fetch "$(dirname "$BOOT")/boot.scr" "$BOOTDIR/boot.scr"
	fetch "$(dirname "$BOOT")/boot.txt" "$BOOTDIR/boot.txt"
	fetch "$(dirname "$BOOT")/uEnv.txt" "$BOOTDIR/uEnv.txt"
	! $DRYRUN && echo "$CMDLINE" >"$BOOTDIR/makesd.info"	# so that we can easily find out for which device this is formatted
	! $DRYRUN && partitions >>"$BOOTDIR/makesd.info"
fi

KERNEL=$(getparam "$P" KERNEL)
KERNELDIR="/media/P${P}/$(getparam "$P" KERNELDIR)/"
if [ "$KERNEL" != none ]
then
	$DEBUG && echo "-- fetch kernel to $KERNELDIR --" >&2
	mkdir -p "$KERNELDIR"
	KDEST="$KERNELDIR/$(basename "$KERNEL")"
	fetch "$KERNEL" "$KDEST"
	fetch "$(dirname "$KERNEL")/bootargs.scr" "$KERNELDIR/bootargs.scr"
	KERNEL_VERSION=$(file "$KDEST")
	KERNEL_VERSION=$(expr "$KERNEL_VERSION" : ".*Linux-\([^,]*\),.*")
	$DEBUG && echo "-- installed $KERNEL_VERSION --" >&2
fi

DT=$(getparam "$P" DT)
DTDIR="/media/P${P}/$(getparam "$P" DTDIR)/"
if [ "$DT" != none ]
then
	$DEBUG && echo "-- fetch device trees to $DTDIR --" >&2
	mkdir -p "$DTDIR"
	fetch "$DT" - | ( cd "$DTDIR" && tar xvjf - )
fi

MODULES=$(getparam "$P" MODULES)
if [ "$MODULES" != none ]
then
	$DEBUG && echo "-- fetch modules to /media/P${P} --" >&2
	fetch "$MODULES" - | (cd "/media/P${P}/" && tar xvzf - --numeric-owner)
	if [ "$KERNEL_VERSION" ] && exists depmod
	then # run depmod on the installed root for the last kernel we have installed
		$DEBUG && echo "-- run depmod $KERNEL_VERSION --" >&2
		depmod -b "/media/P${P}/" "$KERNEL_VERSION"
	fi
fi

CONFIG=$(getparam "$P" CONFIG)
if [ "$CONFIG" != none ]
then
	$DEBUG && echo "-- fetch config patches to /media/P${P} --" >&2
	fetch "$CONFIG" - | (cd "/media/P${P}/" && tar xvzf - --numeric-owner)
fi

XLIST="$(getparam $P XLIST)"
$DEBUG && echo "-- x: $(echo $XLIST) --" >&2

echo "$XLIST" | while read DIRFILE URL
do
	if [ ! "$URL" ]
	then continue
	fi
	$DEBUG && echo "-- fetch file(s) $URL to /media/P${P}/$DIRFILE --" >&2

	for SUFFIX in .tgz .tbz ''
	do
		FILE="$URL$SUFFIX"
		case "$FILE" in
			*.tgz ) fetch "$FILE" - | (mkdir -p "/media/P${P}/$DIRFILE" && cd "/media/P${P}/$DIRFILE" && tar xvzf - --numeric-owner) && break;;	# try to unpack into directory
			*.tbz ) fetch "$FILE" - | (mkdir -p "/media/P${P}/$DIRFILE" && cd "/media/P${P}/$DIRFILE" && tar xvjf - --numeric-owner) && break;;	# try to unpack into directory
			* )
				# if DIRFILE ends in / use basename of url
				# if not, use as qualified file name
				case "$DIRFILE" in
					*/ )	mkdir -p "/media/P${P}/$DIRFILE" && fetch "$FILE" "/media/P${P}/$DIRFILE$(basename "$FILE")" && break;; # load single file
					* )	mkdir -p "$(dirname "$/media/P${P}/DIRFILE")" && fetch "$FILE" "/media/P${P}/$DIRFILE" && break;; # load plain file (with rename)
				esac
			;;
		esac
	done
done

INFO="$(getparam $P INFO)"
if [ "$INFO" ]
then
	$DEBUG && echo "-- write info >/media/P${P}/makesd.info --" >&2
	! $DRYRUN && (
	echo "+++ this system was created by makesd (http://projects.goldelico.com/p/gta04-makesd/) at $(date) +++"
	echo "$CMDLINE"
	partitions
	) >"/media/P${P}/makesd.info"	# so that we can easily find out for which device this is formatted
fi


ls -l /media/P[1-4]

done

$DEBUG && echo "-- sync --" >&2

sync

if [ "$DEV" ]
then
	$DEBUG && echo "-- show mounted partitions --" >&2
	df
	$DEBUG && echo "-- unmount --" >&2
	for P in 1 2 3 4
	do
		sync
		[ -r "/media/P${P}/u-boot.img" ] && file "/media/P${P}/u-boot.img"
		[ -r "/media/P${P}/uImage" ] && file "/media/P${P}/uImage"
		umount ${DEVP}${P} 2>/dev/null
		[ -d "/media/P${P}" ] && rmdir "/media/P${P}"
	done
	$DEBUG && echo "-- fsck --" >&2
	for P in 1 2 3 4
	do
		if [ -b "${DEVP}${P}" ]
		then
			echo "${DEVP}${P}" = $(fsck -T -a -f "${DEVP}${P}")
		fi
	done
fi

$DEBUG && echo "-- done --" >&2
