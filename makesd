#!/bin/bash
#
# makesd
# partition and format an SD card suitable for GTA04 devices (Letux 2804 etc.)
# run this script on some host with a SD interface
# (c) Golden Delicious Comp. GmbH&Co. KG, 2014
# Licenced under GPLv2
#

DEBUG=false
DRYRUN=false
CMDLINE="$0 $@"		# how makesd was called
[ "$DEV" ] && CMDLINE="DEV=$DEV $CMDLINE"

[ "$VARIANT" ] || VARIANT=latest
[ "$ARCHITECTURE" ] || ARCHITECTURE=armhf
[ "$DEV" ] || DEV="$(cat ~/.makesd.conf 2>/dev/null)"
[ "$DEV" ] || DEV=/dev/sdc

## FIXME: also set up macros for -r quantumstep etc.

function macros()
{
# format: macro-pattern macro-body
# it is valid to use shell variables in the body since they are expanded by the here-document
# $1 is expanded by the first argument given to the macros call
# patterns are regexp (expr : command)
# comments (lines starting with "#" can be used and they are ignored
# macros can be recursive

cat <<END
# basic macros
# boot loader
-bnone			$1
-bhttp://.*/.*		$1
-bhttps://.*/.*		$1
-b.*			http://download.goldelico.com/letux-u-boot/$1/u-boot.bin
# kernel
-knone			$1
-khttp://.*/.*		$1
-khttps://.*/.*		$1
-k.*			http://download.goldelico.com/letux-kernel/$1/uImage
# device tree
-dnone			$1
-dhttp://.*/.*		$1
-dhttps://.*/.*		$1
-d.*			http://download.goldelico.com/letux-kernel/$1/device-trees.tbz
# kernel modules
-mnone			$1
-mhttp://.*/.*		$1
-mhttps://.*/.*		$1
-m.*			http://download.goldelico.com/letux-kernel/$1/modules.tgz
# additional config
-cnone			$1
-chttp://.*/.*		$1
-chttps://.*/.*		$1
-c.*			http://download.goldelico.com/letux-debian-rootfs/$1-config.tgz
# rootfs
-rnone			$1
-rhttp://.*/.*		$1
-rhttps://.*/.*		$1
# fixme: apply $ARCHITECTURE here
-rdebian		http://download.goldelico.com/letux-debian-rootfs/$VARIANT-minimal.tbz
-rlxde			http://download.goldelico.com/letux-debian-rootfs/$VARIANT-lxde.tbz
-rxfce			http://download.goldelico.com/letux-debian-rootfs/$VARIANT-xfce4.tbz
-rqtmoko		http://download.goldelico.com/letux-qtmoko/$VARIANT.tbz
-rreplicant		http://download.goldelico.com/letux-replicant/4.2/$VARIANT-replicant.tbz
-rpyra-os		http://packages.pyra-handheld.com/rootfs/pyra-debian-jessie-xfce-rootfs.tgz
-re17			http://download.goldelico.com/letux-debian-rootfs/$VARIANT-e17.tbz
-rquantumstep		http://download.goldelico.com/letux-debian-rootfs/$VARIANT-quantumstep.tbz
# single partition file system(s) - should boot if boot loader is in flash/eMMC
debian			-f ext4 -r debian -kboot latest -dboot latest -m latest -c latest
debian-lxde		debian -r lxde
debian-xfce		debian -r xfce
quantumstep		debian -r quantumstep
qtmoko			debian -c none -r qtmoko
replicant		debian -k none -d none -m none -c none -r replicant
pyra-os			debian -c none -r pyra-os
all 			debian-lxde qtmoko replicant quantumstep
# production images (dual partition) for specific devices
gta04			-f fat -s 5 -b GTA04/latest -k latest -d latest debian-lxde -k none -d none -s 95
l2804			gta04
gta04one		-f fat -s 5 -b GTA04-OneNAND/latest -k latest -d latest debian-lxde -k none -d none -s 95
gta04a5			gta04one
l2804a5			gta04one
gta04b2			-f fat -s 5 -b Letux-3704/latest -k latest -d latest debian-lxde -k none -d none -s 95
l3704			gta04b2
gta04b3			-f fat -s 5 -b Letux-7004/latest -k latest -d latest debian-lxde -k none -d none -s 95
l7004			gta04b3
gta04b7			-f fat -s 5 -b Neo900/latest -k latest -d latest debian-lxde -k none -d none -s 95
neo900			gta04b7
bb			-f fat -s 5 -b Letux-BeagleBoard/latest -k latest -d latest debian-lxde -k none -d none -s 95
beagleboard		bb
bbb			-f fat -s 5 -b Letux-BeagleBone-Black/latest -k latest -d latest debian-lxde -k none -d none -s 95
lc8			-f fat -s 5 -b Letux-Cortex-8/latest -k latest -d latest debian-lxde -k none -d none -s 95
pocketeagle		lc8
bb+b1			-f fat -s 5 -b OpenMoko-Beagle-Hybrid/latest -k latest -d latest debian-lxde -k none -d none -s 95
bb+b2			-f fat -s 5 -b Openmoko-Beagle-Hybrid-b2/latest -k latest -d latest debian-lxde -k none -d none -s 95
bb+b4			-f fat -s 5 -b Openmoko-Beagle-Hybrid-b4/latest -k latest -d latest debian-lxde -k none -d none -s 95
bb+b7			-f fat -s 5 -b BeagleBoard-Neo900/latest -k latest -d latest debian-lxde -k none -d none -s 95
panda-es		-f fat -s 5 -b PandaBoard-ES/latest -k latest -d latest debian-lxde -k none -d none -s 95
omap5432evm		-f fat -s 5 -b OMAP5-uEVM/latest -k latest -d latest debian-lxde -k none -d none -s 95
omap5432evm+pyra	-f fat -s 5 -b OMAP5-uEVM+Pyra4.9/latest -k latest -d latest debian-lxde -k none -d none -s 95
pyra+lc15		-f fat -s 5 -b Pyra+LC15/latest -k latest -d latest debian-lxde -k none -d none -s 95
pyra+lc15-4.9		-f fat -s 5 -b Pyra+LC15-4.9/latest -k latest -d latest debian-lxde -k none -d none -s 95
pyra+lc15-4gb		-f fat -s 5 -b Pyra+LC15-4GB/latest -k latest-lpae -d latest-lpae debian-lxde -m latest-lpae -k none -d none -s 95
pyra			pyra+lc15 -r pyra-os
pyra-lxde		pyra+lc15 -r lxde
pyra-4gb		pyra+lc15-4gb -r pyra-os
lc15			-f fat -s 5 -b Letux-Cortex-15/latest -k latest -d latest debian-lxde -k none -d none -s 95
lc15-4.9		-f fat -s 5 -b Letux-Cortex-15-4.9/latest -k latest -d latest debian-lxde -k none -d none -s 95
lc15-4gb		-f fat -s 5 -b Letux-Cortex-15-4GB/latest -k latest-lpae -d latest-lpae debian-lxde -k none -d none -m latest-lpae -s 95
# for Pandora, a single partition image can boot
openpandora		debian-lxde -b OpenPandora/latest
pandora			openpandora
# Udoo Neo needs a pseudo-single -partition but SPL and u-boot must be copied by dd
udoo-neo		debian-lxde -p 2048 -b Udoo-Neo/latest -kboot latest-udoo -dboot latest-udoo -m latest-udoo
# we must make sure that we load the mipsel variants and not armel/armhf
lenny400		-A mipsel -f fat -s 2 -k http://download.goldelico.com/letux-400/20110208-lenny400/uImage -f ext -r http://download.goldelico.com/letux-400/20110208-lenny400/bootstrapped-rootfs.tbz -c http://download.goldelico.com/letux-400/20110208-lenny400/config.tgz -m http://download.goldelico.com/letux-400/20110208-lenny400/modules.tgz
mipsbook-400		-A mipsel -f fat -s 2 -k latest-l400 -d latest-l400 -f ext -r http://download.goldelico.com/letux-400/20110208-lenny400/bootstrapped-rootfs.tbz -c http://download.goldelico.com/letux-400/20110208-lenny400/config.tgz -m latest-l400
mipsbook		mipsbook-400
letux-400		mipsbook-400
END
}

function lookup()
{
	# "$1" is key
	# returns expanded macro or empty string if not found
	# pass our $1 after stripping -? to $1 within here-document
	local MACRO COMMAND
	macros $(expr "$1" : "-.\(.*\)") | {
		while read MACRO COMMAND
		do
			case "$MACRO" in
				'' | '#' | '#'* )
					continue;;
				* )
					if expr "$1" : "^$MACRO\$" >/dev/null
						then # found
						$DEBUG && echo "$1" matches "$MACRO -> $COMMAND" >&2
						echo "$COMMAND"
						return
					fi
			esac
			done
			$DEBUG && echo "$1" no match >&2
			echo ""
		}
}

function useage()
{

## fixme: list available macros separately

	cat <<END
useage: [DEV=/dev/device] makesd [--dry --debug --help -- update] [partition1 [partition2 [partition3 [partition4]]]]"

  DEV=/dev/device - specify the raw device (not the partitions), e.g. /dev/sdc
  general options:

    --debug -- print internal activities and status
    --dry -- dry run (don't touch SD card)
    --help -- print this help
    -i | --no-format -- install only
    -u | --update -- selfudate
    -a -- list all macros

  partition:
    format (starts next partition):
    -f fat
    -f ext3
    -f ext4
    -f none
    -f[0-4]	switch to given partition - note that another -f will increment by 1
    -F		go back one partition so that we can specify a macro that contains a -f
    -s size	define relative size
    -p sector	force start of partition to a specific sector
    bootloader:
    -b[dir] <url>
    -b[dir] version
    -b none
    device tree files:
    -d[dir] <url>
    -d[dir] version
    -d none
    kernel:
    -k[dir] <url>
    -k[dir] version
    -k none
    modules:
    -m version
    -m none
    config patches:
    -c <url>
    -c none
    root file system (OS):
    -r <url>
    -r none
    -r debian
    -r lxde
    -r quantumstep
    -r replicant
    -r qtmoko
    -r pyra
    -v variant -- choose different variant for -r (default is 'latest')
    -A architecture -- choose different architecture variant

    macros for single partition cards:
      debian-lxde = -f ext4 -r lxde -d all -k latest -m latest -c latest
      qtmoko = -f ext4 -r qtmoko -d all -k latest (does not need config)
      replicant = -f ext4 -d all -r replicant-4.2 (has its own kernel)
      quantumstep = -f ext4 -r quantumstep -d all -k latest -m latest -c latest

    macros for multiple partitions (to create bootable production image SD card):
      gta04 | l2804 = -f fat -b latest debian-lxde
      gta04one | gta04a5 = -f fat -b latest/GTA04A5 debian-lxde
      gta04b2 | l3704 = -f fat -b latest/b2 debian-lxde
      gta04b3 | l7004 = -f fat -b latest/b3 debian-lxde
      gta04b7 | neo900 = -f fat -b latest/b7 debian-lxde
      bb = -f fat -b latest/ beagleboard debian-lxde
      bbb = -f fat -b latest/ beagleboardblack debian-lxde
      panda-es = -f fat -b latest/panda-es debian-lxde
      pyra = -f fat -b latest/ pyra pyra-os
      openpandora = -f fat -b latest/ openpandora debian-lxde
      all = debian-lxde qtmoko replicant quantumstep

examples:"
  ./makesd -- makes a single-partition LXDE image
  ./makesd debian-lxde -- also makes a LXDE image
  ./makesd replicant -- makes a single partition replicant image
  ./makesd all -- makes a 4-partition card
  ./makesd gta04 -- makes the latest stable production (recovery) image for the GTA04 (includes boot loader)
  ./makesd gta04 -f1 -b GTA04/2015-10-25 -- makes the latest image for the GTA04 but use U-Boot from 2015-10-25
  ./makesd gta04 -d letux-4.10.4 -k letux-4.10.4 -m letux-4.10.4 -- replace DT, kernel and modules by specific version
  ./makesd pyra -c none -r http://download.goldelico.com/letux-debian-rootfs/latest-pyra.tbz -- install latest PyraOS
  ./makesd -v unstable gta04 -- makes an unstable production image
  ./makesd -v unstable gta04 -f1 quantumstep -- makes an unstable production image but with quantumstep rootfs
  ./makesd -v 20141006-GTA04-beta-3.17.0-wheezy-7.6 l3704 -- makes the specified version for the Letux 3704
  DEV=/dev/sdd ./makesd --dry -- does a dry run on /dev/sdd (instead of sdc)
  ./makesd -u -- self-update
  DEV=/dev/sdd ./makesd omap5432evm -f1 -b OMAP5432-uEVM/2016-05-10 -k letux-4.8-rc6 -d letux-4.8-rc6 -f2 -m letux-4.8-rc6 xfce
  DEV=/dev/sdb ./makesd pyra -f1 -k letux-4.11-rc4 -d letux-4.11-rc4 -v 20170401-jessie-8.7 debian-lxde -m letux-4.11-rc4

END
}

function setparam()
{ # $partition $name $value
	if [ "$1" -lt 1 -o "$1" -gt 4 ]
		then
		echo "invalid partition number $1" >&2
		useage
		exit 1
	fi
	$DEBUG && echo setparam $1 $2 $3
	eval $2$1="'$3'"
}

function getparam()
{ # $partition $name
	eval echo \$$2$1
}

function process()
{ # $1 .. $n
	while [ "$1" ]
		do
		case "$1" in
			-f[0-4] ) # switch to given partition (but don't change type)
				NP=$(expr "$1" : "-f\(.*\)" )
				# FIXME: check type!
				$DEBUG && echo "switched to partition $NP" >&2
				;;
			-F ) # switch to previous partition
				NP=$(expr "$NP" - 1)
				if [ "$NP" -lt 0 ]
				then
					echo "can't go back that far" >&2
					useage
					exit 1
				fi
				;;
			-f ) # switch to next partition
				NP=$(expr "$NP" + 1)
				if [ "$NP" -gt 4 ]
				then
					echo "too many partitions specified (max. 4)" >&2
					useage
					exit 1
				fi
				shift
				setparam $NP FORMAT "$1"
				setparam $NP SIZE "25"
				if [ "$1" = "none" ]
					then # don't install anything
					setparam $NP BOOT "none"
					setparam $NP KERNEL "none"
					setparam $NP MODULES "none"
					setparam $NP DT "none"
					setparam $NP ROOTFS "none"
					setparam $NP CONFIG "none"
				fi
				;;
			-s ) # define relative size (typically in %)
				shift
				setparam $NP SIZE "$1"
				;;
			-p ) # define partition start sector
				shift
				setparam $NP PSTART "$1"
				;;
			-b* ) # define boot loader
				setparam $NP BOOTDIR "$(expr "$1" : "-b\(.*\)")"
				shift
				$DEBUG && echo "bootloader $1" >&2
				local P=$(lookup "-b$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP BOOT "$P"
				;;
			-k* ) # define kernel
				setparam $NP KERNELDIR "$(expr "$1" : "-k\(.*\)")"
				shift
				$DEBUG && echo "kernel $1" >&2
				local P=$(lookup "-k$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP KERNEL "$P"
				;;
			-m ) # define modules
				shift
				$DEBUG && echo "modules $1" >&2
				local P=$(lookup "-m$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP MODULES "$P"
				;;
			-d* ) # define device trees
				setparam $NP DTDIR "$(expr "$1" : "-d\(.*\)")"
				shift
				$DEBUG && echo "device trees $1" >&2
				local P=$(lookup "-d$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP DT "$P"
				;;
			-r ) # define root file system
				shift
				$DEBUG && echo "rootfs $1" >&2
				local P=$(lookup "-r$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP ROOTFS "$P"
				;;
			-c ) # define additional config
				shift
				$DEBUG && echo "config $1" >&2
				local P=$(lookup "-c$1")
				if [ ! "$P" ]
				then
					echo "unknown macro: -k $1" >&2; useage >&2; exit 1
				fi
				setparam $NP CONFIG "$P"
				;;
			-v ) # define variant
				shift
				$DEBUG && echo "variant $1" >&2
				[ "$1" ] && VARIANT="$1"	# overwrite
				;;
			-A ) # define architecture
				shift
				$DEBUG && echo "architecture $1" >&2
				[ "$1" ] && ARCHITECTURE="$1"	# overwrite
				;;


			-* )
				echo "unknown option: $1" >&2; useage >&2; exit 1
				;;
			* )
				local COMMAND=$(lookup "$1")
				if [ "$COMMAND" ]
				then
					process $COMMAND
				else
					echo "unknown macro: $1" >&2; useage >&2; exit 1
				fi
				;;
		esac
		shift
	done
}

function fetch()
{ # $url $dest - make sure that $dest exists only on success
	$DEBUG && echo "-- fetch $1 $2 --" >&2
	if $DRYRUN
	then
		echo "fetch $1 -> $2" >&2
	elif which wget >/dev/null
	then # wget exists
		if [ "$2" = "-" ]
		then # to stdout
			$DEBUG && echo "-- wget -O - $1 --" >&2
			wget -O - "$1"
		else
			$DEBUG && echo "-- wget -O - $1 >$2 --" >&2
			wget -O - "$1" >"$2" || rm "$2"
		fi
	elif which curl >/dev/null
	then # try curl
		if [ "$2" = "-" ]
		then # to stdout
			$DEBUG && echo "-- curl $1 --" >&2
			curl "$1"
		else
			$DEBUG && echo "-- curl $1 -o $2 --" >&2
			curl "$1" -o "$2" || rm "$2"
		fi
	else
		echo "error: can't fetch files (please install 'wget' or 'curl')" >&2
		exit 1
	fi
}

function exists()
{ # check if tool exists
	which $1 2>/dev/null
}

function partitions()
{ # print partition table
	local P
	for P in 1 2 3 4
	do
		FORMAT="$(getparam "$P" FORMAT)"
		SIZE="$(getparam "$P" SIZE)"
		[ "$FORMAT" = none ] && SIZE=0
		BOOT="$(getparam "$P" BOOT)"
		[ "$BOOT" != none ] && BOOT="$(dirname "$BOOT")/*" # remove u-boot.bin and replace
		BOOTDIR=/"$(getparam "$P" BOOTDIR)"
		KERNEL="$(getparam "$P" KERNEL)"
		KERNELDIR="/$(getparam "$P" KERNELDIR)"
		DT="$(getparam "$P" DT)"
		DTDIR="/$(getparam "$P" DTDIR)"
		ROOTFS="$(getparam "$P" ROOTFS)"
		MODULES="$(getparam "$P" MODULES)"
		CONFIG="$(getparam "$P" CONFIG)"
		echo "$P: $FORMAT $SIZE% b:$BOOTDIR+$BOOT k:$KERNELDIR+$KERNEL dt:$DTDIR+$DT r:$ROOTFS m:$MODULES c:$CONFIG"
	done
}

setparam 2 KERNEL 1234
_TESTME=$(getparam 2 KERNEL)
if [ "$_TESTME" != 1234 ]
then
	echo "error: getparam and setparam did not pass internal test - please check shell or script" >&2
	set
	exit
fi
unset _TESTME

while [ "$1" ]
do
	case "$1" in
		"-a" )	# list all macros
		macros | while read MACRO COMMAND
				do
				case "$MACRO" in
					'' | '#' | '#'* )	continue;;	# comment
					-* | '*' )		continue;;	# pattern
					* )			echo "$MACRO";;
				esac
			done | sort
			exit
			;;
		"-i" | "--no-format" )
			NOFORMAT=yes
			;;
		"-u" | "--update" )	# self-update
			$DEBUG && echo "-- self-update --" >&2
			fetch "http://git.goldelico.com/?p=gta04-makesd.git;a=blob_plain;hb=HEAD;f=$(basename $0)" "$(basename $0).new" &&
			chmod +x $(basename $0).new &&
			mv $(basename $0).new $(basename $0)
			exit
			;;
		"--debug" )
			DEBUG=true
			;;
		"--dry" )
			DRYRUN=true
			;;
		"--help" )
			useage
			exit
			;;
		* )
			break
			;;
	esac
	shift
done

$DEBUG && echo "-- define defaults --" >&2
NP=0
process -f none -f none -f none -f none

if [ "$1" ]
then
	$DEBUG && echo "-- start over with given options --" >&2
	# start over with given options
	NP=0
	process "$@" || exit 1
fi

partitions

$DEBUG && echo "-- prepare $DEV --" >&2

if [ "${DEV}" = "/dev/sda" ]
then
	echo "error: refuses to overwrite /dev/sda" >&2
	exit 1
fi

if ! [ -b "$DEV" ] && ! $DRYRUN
then
	echo "error: not a block device: $DEV" >&2
	exit 1
fi

DEVP=$DEV
if [ -b "${DEV}p1" ] || expr "${DEV}" : "/dev/mmc.*" >/dev/null
then
	DEVP=${DEV}p	# MMC card reader expects "p"artition suffix (hard coded into kernel)
	$DEBUG && echo "-- suffix p added --" >&2
fi

$DEBUG && echo "-- unmount partitions --" >&2

function totalsize()
{ # also create mount points!
local P
TOTALSIZE=0
for P in 1 2 3 4
do
	umount -f ${DEVP}${P} 2>/dev/null
	wait
	case "$(getparam $P FORMAT)" in
		none )
			## check if this is the last or only followed by "none"
			## i.e. there can't be "holes" in the partition numbers
			;; # skip
		fat | ext* | swap )
			! $DRYRUN && mkdir -p /media/P${P}
			TOTALSIZE=$(expr "$TOTALSIZE" + "$(getparam $P SIZE)")	# sum up
			;;
		* )
			echo "error: invalid partition type '$(getparam $P FORMAT)' for partition $P" >&2
			exit 1
			;;
	esac
done
}

# make sure we are not mounted anywhere else
umount /boot /boot
umount ${DEV}*
sleep 2
umount ${DEV}*

totalsize

ls -l /media/P[1-4]

$DEBUG && echo "-- total size $TOTALSIZE --" >&2

if ! [ "$NOFORMAT" ]
then

$DEBUG && echo "-- clear boot record --" >&2
if ! $DRYRUN
then
	dd if=/dev/zero of=$DEV bs=1024 count=1024	# clear boot records
	dd if=/dev/urandom bs=1 count=4 seek=440 of=$DEV	# write a fresh random unique disk identifier (MBR)
fi

## the following code is roughly
## based on: http://omappedia.org/wiki/SD_Configuration#Script_to_partition.2Fformat_SDCards
## and: http://www.sakoman.com/OMAP/a-script-for-partitioningformatting-a-bootable-sdmicrosd-card.html

$DEBUG && echo "-- partitioning --" >&2

function sfdisk_table()
{ # run in an anonymous function, not a subprocess
TS=$TOTALSIZE	# save for next call
SIZE=$(LC_ALL=C LANGUAGE=C fdisk -l "$DEV" | grep Disk | awk '{print $5}')	# make sure fdisk runs in default LANGUAGE
#SIZE=$(expr 1024 '*' $(sfdisk -s "$DEV"))	# total size in bytes - but why 1024? is this well defined?
$DEBUG && echo "-- DISK SIZE: $SIZE bytes --" >&2
TOTALSECTORS=$(expr "$SIZE" / 512)
$DEBUG && echo "-- TOTAL SECTORS: $TOTALSECTORS --" >&2
SECTORS=63
HEADS=255
CYLINDERS=$(expr "$TOTALSECTORS" / "$HEADS" / "$SECTORS")
$DEBUG && echo "-- CYLINDERS: $CYLINDERS --" >&2
SECTORSPERCYLINDER=$(expr "$TOTALSECTORS" / "$CYLINDERS")
$DEBUG && echo "-- SECTORS PER CYLINDER: $SECTORSPERCYLINDER --" >&2
PSTART=128
local P
for P in 1 2 3 4
do # calculate sizes of partitions
	FORMAT=$(getparam $P FORMAT)
	PS=$(getparam $P PSTART)
	[ "$PS" ] || PS=$PSTART
	REMAINING=$(expr "$TOTALSECTORS" - "$PS")
	THISSIZE=$(getparam $P SIZE)
	[ "$FORMAT" = none ] && THISSIZE=0	# overwrite (has not been counted for TOTALSIZE)
	if [ "$THISSIZE" = "$TOTALSIZE" ]
	then # last partition
		PSECTORS="$REMAINING"	# take all remaining sectors
	elif [ "$TOTALSIZE" -gt 0 ]
	then # intermediate partition
		PE=$(getparam $(expr $P + 1) PSTART)
		if [ "$PE" ]
		then # next sector has specified explicit start
			PSECTORS=$(expr "$PE" - "$PSTART")
		else
			PSECTORS=$(expr \( "$REMAINING" '*' "$THISSIZE" \) / "$TOTALSIZE")
		fi
#		S1=$PSECTORS
#		echo "S1: $S1" >&2
#		S2=$(expr "$PSTART" + "$S1" + "$SECTORSPERCYLINDER" - 1 )
#		echo "S2: $S2" >&2
#		S3=$(expr "$S2" / "$SECTORSPERCYLINDER" )
#		echo "S3: $S3" >&2
#		PSECTORS=$(expr \( \( "$PSTART" + "$PSECTORS" + "$SECTORSPERCYLINDER" - 1 \) / "$SECTORSPERCYLINDER" \) "*" "$SECTORSPERCYLINDER" - "$PSTART") # round up to end of full cylinder boundary
	else
		PSECTORS=0	# must be a "none"
	fi
	TOTALSIZE=$(expr "$TOTALSIZE" - "$THISSIZE")	# this is not exactly correct
	PSTART=$(expr "$PS" + "$PSECTORS")	# calculated start of next partition
if $DEBUG
then
	echo "P: $P" >&2
	echo "FORMAT: $FORMAT" >&2
	echo "REMAINING: $REMAINING" >&2
	echo "THISSIZE: $THISSIZE ($TOTALSIZE)" >&2
	echo "SECTORS: $PS + $PSECTORS .. $PSTART" >&2
fi
	# FIXME: use "Named-fields format" to specify data for a specific partition
	# e.g. $P: start=$PS,size=$PSECTORS,type=0c,bootable
	# e.g. $P: start=$PS,size=$PSECTORS,type=83
	# but sfdisk in Debian Jessie does not yet understand
	case "$FORMAT" in
		none )
			: skip # (how with sfdisk? do we have to read the current partition sizes)
			# this gives the wrong impression that we could define just a partition 3 and none for 1 & 2
			echo "$PS,0,0,-"	# empty partition (bootable)
			;;
		fat )
			# echo "$P: start=$PSTART,size=$PSECTORS,type=0c,bootable"	# FAT partition (bootable)
			echo "$PS,$PSECTORS,0x0C,*"	# FAT partition (bootable)
			;;
		ext* )
			# echo "$P: start=$PSTART,size=$PSECTORS,type=83"	# Linux partition
			echo "$PS,$PSECTORS,83,-"	# Linux partition
			;;
		swap )
			## echo "$P: start=$PSTART,size=$PSECTORS,type=82"	# Linux swap partition
			echo "$PS,$PSECTORS,82,-"	# Linux swap partition
			;;
	esac
done
if [ "$TOTALSIZE" != 0 -o "$REMAINING" != 0 ]
	then
	echo "error: error in partition calculation" >&2
	echo "TOTALSIZE: $TOTALSIZE" >&2
	echo "REMAINING: $REMAINING" >&2
	echo "did yo specify 4 empty partitions?" >&2
	exit 1
fi
TOTALSIZE=$TS	# restore for next call
}

if $DRYRUN
then
	sfdisk_table >&2
else
	$DEBUG && sfdisk_table >&2
	sfdisk_table | sfdisk -L --force -uS "$DEV" | exit 1
	sleep 2
	# this may try to remount!
	[ -x /sbin/partprobe ] && /sbin/partprobe "$DEV"
	# alternative? blockdev --rereadpt "$DEV"
	sleep 2
fi

# fdisk -l "$DEV"

$DEBUG && echo "-- format partitions --" >&2

fi	# ! NOFORMAT

if ! $DRYRUN
then
for P in 1 2 3 4
do # format and mount partitions
	umount ${DEVP}${P} 2>/dev/null
	sleep 1
	case "$(getparam $P FORMAT)" in
		none )
			: skip
			;;
		fat )
			if ! [ "$NOFORMAT" ]
			then
				mkfs.vfat -F 32 -n "boot" ${DEVP}${P} &&
				fsck.vfat -a -y ${DEVP}${P}
			fi
			mount ${DEVP}${P} /media/P${P} || exit
			;;
		ext* )
			if ! [ "$NOFORMAT" ]
			then
				# FIXME: make different volume names for different rootfs???
				PNAME="rootfs"
				yes | mke2fs -j -L "${PNAME}" ${DEVP}${P} &&
				fsck.ext3 -y ${DEVP}${P}
			fi
			mount ${DEVP}${P} /media/P${P} || exit
			;;
		swap )
			mkswap -L "swap$P" ${DEVP}${P}
			;;
	esac
done
fi

df # should have been formatted and mounted now

$DEBUG && echo "-- variables --" >&2
$DEBUG && set >&2

$DEBUG && echo "-- install --" >&2

KERNEL_VERSION=""

for P in 1 2 3 4
do

FORMAT=$(getparam "$P" FORMAT)
if [ "$FORMAT" = "none" -o "$FORMAT" = "swap" -o ! -d /media/P${P} ]
then
	continue	# skip
fi

## FIXME: should also try .tbz and .tgz
## FIXME: and we should be able to unpack .dd.bz2 or img.bz2

ROOTFS=$(getparam "$P" ROOTFS)
if [ "$ROOTFS" != none ]
then # a rootfs must be installed first so that we can overwrite by a kernel

	$DEBUG && echo "-- fetch rootfs to /media/P${P} --" >&2
	ls -l /media/P${P}
	# run in a subshell so that we can really redirect ouput
	case "$ROOTFS" in
	*.tgz ) fetch "$ROOTFS" - | ( cd "/media/P${P}" && tar xvzf - --numeric-owner ) ;;
	*.tbz ) fetch "$ROOTFS" - | ( cd "/media/P${P}" && tar xvjf - --numeric-owner ) ;;
	* )	echo "-- don't know how to unpack $ROOTFS --" >&2; exit ;;
	esac
fi

BOOT=$(getparam "$P" BOOT)
BOOTDIR="/media/P${P}/$(getparam "$P" BOOTDIR)/"
if [ "$BOOT" != none ]
then
	$DEBUG && echo "-- fetch boot loader to $BOOTDIR --" >&2
	mkdir -p "$BOOTDIR" || exit
	#
	# loading some files may fail since they do not exist for the chosen variant - but we ignore
	#
	fetch "$(dirname "$BOOT")/MLO" "$BOOTDIR/MLO"	# must come first
	fetch "$(dirname "$BOOT")/x-load.flash" "$BOOTDIR/x-load.flash"
	fetch "$(dirname "$BOOT")/MLO.flash" "$BOOTDIR/MLO.flash"
	fetch "$BOOT" "$BOOTDIR/u-boot.bin"
	fetch "$(dirname "$BOOT")/u-boot.img" "$BOOTDIR/u-boot.img"	# some x-loaders want u-boot.bin others want u-boot.img (e.g. the OMAP5 MLO)
	fetch "$(dirname "$BOOT")/u-boot.flash" "$BOOTDIR/u-boot.flash"
	fetch "$(dirname "$BOOT")/u-boot.img.flash" "$BOOTDIR/u-boot.img.flash"
	fetch "$(dirname "$BOOT")/splash.rgb16z" "$BOOTDIR/splash.rgb16z"
	fetch "$(dirname "$BOOT")/menu.rgb16z" "$BOOTDIR/menu.rgb16z"
	fetch "$(dirname "$BOOT")/boot.scr" "$BOOTDIR/boot.scr"
	fetch "$(dirname "$BOOT")/boot.txt" "$BOOTDIR/boot.txt"
	fetch "$(dirname "$BOOT")/uEnv.txt" "$BOOTDIR/uEnv.txt"
	! $DRYRUN && echo "$CMDLINE" >"$BOOTDIR/makesd.info"	# so that we can easily find out for which device this is formatted
#echo test for Udoo-Neo: "$BOOT" >&2
	B=$(dirname "$BOOT");
#echo test for Udoo-Neo: "$B" >&2
	B=$(dirname "$B");
#echo test for Udoo-Neo: "$B" >&2
	B=$(basename "$B");
#echo test for Udoo-Neo: "$B" >&2
	if [ "$B" = "Udoo-Neo" ]
	then # hack: special rule for installing SPL&U-Boot on Udoo-Neo
	     # it should be possible to specify the dd command by macro options, e.g. -dd:sector=file
		fetch "$(dirname "$BOOT")/SPL" - | dd of=$DEV bs=1K seek=1
		fetch "$(dirname "$BOOT")/u-boot.img" - | dd of=$DEV bs=1K seek=69
	fi
	! $DRYRUN && partitions >>"$BOOTDIR/makesd.info"
fi

KERNEL=$(getparam "$P" KERNEL)
KERNELDIR="/media/P${P}/$(getparam "$P" KERNELDIR)/"
if [ "$KERNEL" != none ]
then
	$DEBUG && echo "-- fetch kernel to $KERNELDIR --" >&2
	mkdir -p "$KERNELDIR"
	KDEST="$KERNELDIR/$(basename "$KERNEL")"
	fetch "$KERNEL" "$KDEST"
	fetch "$(dirname "$KERNEL")/bootargs.scr" "$KERNELDIR/bootargs.scr"
	KERNEL_VERSION=$(file "$KDEST")
	KERNEL_VERSION=$(expr "$KERNEL_VERSION" : ".*Linux-\([^,]*\),.*")
	$DEBUG && echo "-- installed $KERNEL_VERSION --" >&2
fi

DT=$(getparam "$P" DT)
DTDIR="/media/P${P}/$(getparam "$P" DTDIR)/"
if [ "$DT" != none ]
then
	$DEBUG && echo "-- fetch device trees to $DTDIR --" >&2
	mkdir -p "$DTDIR"
	fetch "$DT" - | ( cd "$DTDIR" && tar xvjf - )
fi

MODULES=$(getparam "$P" MODULES)
if [ "$MODULES" != none ]
then
	$DEBUG && echo "-- fetch modules to /media/P${P} --" >&2
	fetch "$MODULES" - | (cd "/media/P${P}/" && tar xvzf - --numeric-owner)
	if [ "$KERNEL_VERSION" ] && exists depmod
	then # run depmod on the installed root for the last kernel we have installed
		$DEBUG && echo "-- run depmod $KERNEL_VERSION --" >&2
		depmod -b "/media/P${P}/" "$KERNEL_VERSION"
	fi
fi

CONFIG=$(getparam "$P" CONFIG)
if [ "$CONFIG" != none ]
then
	$DEBUG && echo "-- fetch config patches to /media/P${P} --" >&2
	fetch "$CONFIG" - | (cd "/media/P${P}/" && tar xvzf - --numeric-owner)
fi

ls -l /media/P[1-4]

done

$DEBUG && echo "-- sync --" >&2

sync

if [ "$DEV" ]
then
	$DEBUG && echo "-- show mounted partitions --" >&2
	df
	$DEBUG && echo "-- unmount --" >&2
	for P in 1 2 3 4
	do
		sync
		umount ${DEVP}${P} 2>/dev/null
		rmdir /media/P${P}
	done
	$DEBUG && echo "-- fsck --" >&2
	for P in 1 2 3 4
	do
		fsck -a -f ${DEVP}${P}
	done
fi

$DEBUG && echo "-- done --" >&2
