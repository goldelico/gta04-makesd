#!/bin/bash
#
# makesd
# partition and format an SD card suitable for GTA04 devices (Letux 2804 etc.)
# run this script on some host with a SD interface
# (c) Golden Delicious Comp. GmbH&Co. KG, 2014
# Licenced under GPLv2
#

DEBUG=false
DRYRUN=false
[ "$VARIANT" ] || VARIANT=latest
[ "$DEV" ] || DEV=/dev/sdc

function useage()
{
	echo "useage: [DEV=/dev/device] makesd [--dry --debug --help -- update] [partition1 [partition2 [partition3 [partition4]]]]"
	echo
	echo "  DEV=/dev/device - specify the raw device (not the partitions), e.g. /dev/sdc"
	echo "  general options:"
	echo "  partition:"
	echo "    -u | --update -- selfudate"
	echo "    --dry -- dry run (don't touch SD card)"
	echo "    --debug -- print internal activities and status"
	echo "    --help -- print this help"
	echo "    format (starts next partition):"
	echo "    -f fat"
	echo "    -f ext3"
	echo "    -f ext4"
	echo "    -f none"
	echo "    -f[0-4] -- switch to given partition - note that another -f will increment by 1"
	echo "    -s size -- define relative size"
	echo "    bootloader:"
	echo "    -b <url>"
	echo "    -b version"
	echo "    -b none"
	echo "    kernel:"
	echo "    -k <url>"
	echo "    -k version"
	echo "    -k none"
	echo "    modules (must come after kernel):"
	echo "    -m none"
	echo "    -m version"
	echo "    device tree files (mst come after kernel):"
	echo "    -d omap3-gta04a2"
	echo "    -d <pattern>"
	echo "    -d '*'"
	echo "    root file system (OS):"
	echo "    -r <url>"
	echo "    -r none"
	echo "    -r debian"
	echo "    -r debian-lxde"
	echo "    -r quantumstep"
	echo "    -r replicant"
	echo "    -r qtmoko"
	echo "    config patches:"
	echo "    -c <url>"
	echo "    -c none"
	echo "    -c debian-wheezy"
	echo "    choose variant:"
	echo "    -v variant -- default is 'latest'"
	echo "    abbreviations for single partition cards:"
	echo "      debian-lxde = -f ext4 -r debian-lxde -d all -k latest -m latest -c debian-wheezy"
	echo "      qtmoko = -f ext4 -r qtmoko -d all -k latest (does not need config)"
	echo "      replicant = -f ext4 -d all -r replicant-4.2 (has its own kernel)"
	echo "      quantumstep = -f ext4 -r quantumstep -d all -k latest -m latest -c debian-wheezy"
	echo "    abbreviations for multiple partitions (to create bootable production image SD card):"
	echo "      gta04 | l2804 = -f fat -b latest debian-lxde"
	echo "      gta04b2 | l3704 = -f fat -b latest/b2 debian-lxde"
	echo "      gta04b3 | l7004 = -f fat -b latest/b3 debian-lxde"
	echo "      gta04b7 | neo900 = -f fat -b latest/b7 debian-lxde"
	echo "      panda-es = -f fat -b latest/panda-es debian-lxde"
	echo "      pyra = -f fat -b latest/ pyra debian-lxde"
	echo "      all = debian-lxde qtmoko replicant quantumstep"
	echo ""
	echo "examples:"
	echo "  ./makesd -- makes a single-partition LXDE image"
	echo "  ./makesd debian-lxde -- also makes a LXDE image"
	echo "  ./makesd replicant -- makes a single partition replicant image"
	echo "  ./makesd gta04 -- makes the latest stable production image for the GTA04"
	echo "  ./makesd all -- makes a 4-partition card"
	echo "  ./makesd -v unstable gta04 -- makes an unstable production image"
	echo "  ./makesd -v unstable gta04 -f1 quantumstep -- makes an unstable production image but with quantumstep rootfs"
	echo "  ./makesd -v 20141006-GTA04-beta-3.17.0-wheezy-7.6 l3704 -- makes the specified version for the Letux 3704"
	echo "  DEV=/dev/sdd ./makesd --dry -- does a dry run on /dev/sdd (instead of sdc)"
	echo "  ./makesd -u -- self-update"
}

function setparam() { # $partition $name $value
	$DEBUG && echo setparam $1 $2 $3
	eval $2$1="'$3'"
}

function getparam() { # $partition $name
	eval echo \$$2$1
}

setparam 2 KERNEL 1234
_TESTME=$(getparam 2 KERNEL)
if [ "$_TESTME" != 1234 ]
then
	echo "error: getparam and setparam did not pass internal test - please check shell or script" >&2
	set
	exit
fi
unset _TESTME

function process() { # $1 .. $n
	while [ "$1" ]
		do
		case "$1" in
			-f[0-4] ) # switch to given partition (but don't change type)
				NP=$(expr "$1" : "-f\(.*\)" )
				$DEBUG && echo "switched to partition $NP" >&2
				;;
			-f ) # switch to next partition
				NP=$(expr "$NP" + 1)
				if [ "$NP" -gt 4 ]
				then
					echo "too many partitions specified (max. 4)" >&2
					useage
					exit 1
				fi
				shift
				setparam $NP FORMAT "$1"
				setparam $NP SIZE "25"
				setparam $NP BOOT "none"
				setparam $NP KERNEL "none"
				setparam $NP MODULES "none"
				setparam $NP DT "none"
				setparam $NP ROOTFS "none"
				setparam $NP CONFIG "none"
				;;
			-s ) # define relative size (typically in %)
				shift
				setparam $NP SIZE "$1"
				;;
			-b ) # define boot loader
				shift
				$DEBUG && echo "bootloader $1" >&2
				case "$1" in
					none ) P="$1";;
					http://*/* | https://*/* ) P="$1";;
					* ) P="http://download.goldelico.com/gta04-u-boot/$1/u-boot.bin" ;;
				esac
				setparam $NP BOOT "$P"
				;;
			-k ) # define kernel
				shift
				$DEBUG && echo "kernel $1" >&2
				case "$1" in
					none ) P="$1";;
					http://*/* | https://*/* ) P="$1";;
					* ) P="http://download.goldelico.com/gta04-kernel/$1/uImage" ;;
				esac
				setparam $NP KERNEL "$P"
				;;
			-m ) # define modules
				shift
				$DEBUG && echo "modules $1" >&2
				case "$1" in
					none ) P="$1";;
					http://*/* | https://*/* ) P="$1";;
					* ) P="http://download.goldelico.com/gta04-kernel/$1/modules.tgz" ;;
				esac
				setparam $NP MODULES "$P"
				;;
			-d ) # define device trees
				shift
				$DEBUG && echo "device trees $1" >&2
				case "$1" in
					none ) P="$1";;
					* ) P="http://download.goldelico.com/gta04-kernel/$1/device-trees.tbz" ;;
					* ) P="$1";;
				esac
				setparam $NP DT "$P"
				;;
			-r ) # define root file system
				shift
				$DEBUG && echo "rootfs $1" >&2
				case "$1" in
					none ) P="$1";;
					http://*/* | https://*/* ) P="$1";;
					debian ) P="http://download.goldelico.com/gta04-debian-lxde/${VARIANT}-debian.tbz" ;;
					lxde ) P="http://download.goldelico.com/gta04-debian-lxde/${VARIANT}-lxde.tbz" ;;
					qtmoko ) P="http://download.goldelico.com/gta04-qtmoko/${VARIANT}.tbz" ;;
					replicant ) P="http://download.goldelico.com/gta04-replicant/4.2/${VARIANT}-replicant.tbz" ;;
					quantumstep ) P="http://download.goldelico.com/quantumstep/debian/${VARIANT}-quantumstep.tbz" ;;
					* ) echo "unknown rootfs: $1" >&2; useage; exit 1 ;;
				esac
				setparam $NP ROOTFS "$P"
				;;
			-c ) # define config
				shift
				$DEBUG && echo "config $1" >&2
				case "$1" in
					none ) P="$1";;
					http://*/* | https://*/* ) P="$1";;
					* ) P="http://download.goldelico.com/gta04-kernel/$1/config.tgz" ;;
				esac
				setparam $NP CONFIG "$P"
				;;
			-v ) # define variant
				shift
				$DEBUG && echo "variant $1" >&2
				[ "$1" ] && VARIANT="$1"	# overwrite
				;;
			# single partition file system(s)
			debian )	process -f ext4 -r debian -k "$VARIANT" -d "$VARIANT" -m "$VARIANT" -c "$VARIANT" ;;
			debian-lxde )	process -f ext4 -r lxde -k "$VARIANT" -d "$VARIANT" -m "$VARIANT" -c "$VARIANT" ;;
			qtmoko )	process -f ext4 -r qtmoko -k "$VARIANT" -d "$VARIANT" -m none -c none ;;
			replicant )	process -f ext4 -r replicant -k none -d none -m none -c none ;;
			quantumstep )	process -f ext4 -r quantumstep -k "$VARIANT" -d "$VARIANT" -m "$VARIANT" -c "$VARIANT" ;;
			all )		process debian-lxde qtmoko replicant quantumstep ;;
			# production images (dual partition) for all hardware variants
			gta04 | l2804 )	process -f fat -s 5 -b "$VARIANT" -k "$VARIANT" debian-lxde -k none -s 95 ;;
			gta04b2 | l3704 )	process -f fat -s 5 -b "$VARIANT/b2" -k "$VARIANT" -d "$VARIANT" debian-lxde -k none -s 95 ;;
			gta04b3 | l7004 )	process -f fat -s 5 -b "$VARIANT/b3" -k "$VARIANT" -d "$VARIANT" debian-lxde -k none -s 95 ;;
			gta04b7 | neo900 )	process -f fat -s 5 -b "$VARIANT/b7" -k "$VARIANT" -d "$VARIANT" debian-lxde -k none -s 95 ;;
			bbb )		process -f fat -s 5 -b "$VARIANT/beagleboneblack" -k "$VARIANT" -d "$VARIANT" debian-lxde -k none -s 95 ;;
			bb+b1 )		process -f fat -s 5 -b "$VARIANT/beagleboard+b1" -k "$VARIANT" -d "$VARIANT" debian-lxde -k none -s 95 ;;
			bb+b2 )		process -f fat -s 5 -b "$VARIANT/beagleboard+b2" -k "$VARIANT" -d "$VARIANT" debian-lxde -k none -s 95 ;;
			bb+b4 )		process -f fat -s 5 -b "$VARIANT/beagleboard+b4" -k "$VARIANT" -d "$VARIANT" debian-lxde -k none -s 95 ;;
			bb+b5 )		process -f fat -s 5 -b "$VARIANT/beagleboard+b7" -k "$VARIANT" -d "$VARIANT" debian-lxde -k none -s 95 ;;
			panda-es )	process -f fat -s 5 -b "$VARIANT/panda-es" -k "$VARIANT" -d "$VARIANT" debian-lxde -k none -s 95 ;;
			omap5432evm | pyra )	process -f fat -s 5 -b "$VARIANT/pyra" -k "$VARIANT" -d "$VARIANT" debian-lxde -s 95 ;;
			openpandora )	process debian-lxde -b "$VARIANT/openpandora" ;;
			-* )		echo "unknown option: $1" >&2; useage >&2; exit 1 ;;
			* )		echo "unknown macro: $1" >&2; useage >&2; exit 1 ;;
		esac
		shift
	done
}

function fetch() { # $url $dest
	$DEBUG && echo "-- fetch $1 $2 --" >&2
	if $DRYRUN
	then
		echo "fetch $1 -> $2" >&2
	elif which wget >/dev/null
	then # wget exists
		$DEBUG && echo "-- wget -O - $1 >$2 --" >&2
		if [ -w "$2" ]
		then # exists and we directly can write (might be /dev/fd/1)
			wget -O - "$1" >"$2"
		else # write to a temp file and check for complete download
			wget -O - "$1" >/tmp/$$ && mv /tmp/$$ "$2"
		fi
	elif which curl >/dev/null
	then # try curl
		$DEBUG && echo "-- curl $1 -o $2 --" >&2
		curl "$1" -o "$2"
	else
		echo "error: can't fetch files (needs wget or curl)" >&2
		exit 1
	fi
}

function exists() { # check if tool exists
	which $1 2>/dev/null
}

while [ "$1" ]
do
	case "$1" in
		"-u" | "--update" )	# self-update
			$DEBUG && echo "-- self-update --" >&2
			fetch "http://git.goldelico.com/?p=gta04-makesd.git;a=blob_plain;hb=HEAD;f=$(basename $0)" "$(basename $0).new" &&
			chmod +x $(basename $0).new &&
			mv $(basename $0).new $(basename $0)
			exit
			;;
		"--debug" )
			DEBUG=true
			shift
			;;
		"--dry" )
			DRYRUN=true
			shift
			;;
		"--help" )
			useage
			exit
			;;
		* )
			break
			;;
	esac
done

$DEBUG && echo "-- define defaults --" >&2
NP=0
process debian-lxde -f none -f none -f none

if [ "$1" ]
then
	$DEBUG && echo "-- start over with given options --" >&2
	# start over with given options
	NP=0
	process "$@" || exit 1
fi

$DEBUG && echo "-- prepare $DEV --" >&2

DEVP=$DEV
if ! $DRYRUN
then
	if [ -b "${DEV}p" ]
	then
		DEVP=${DEV}p	# needs "p"artition suffix
		$DEBUG && echo "-- suffix p added --" >&2
	fi

	if [ "${DEV}" = "/dev/sda" ]
	then
		echo "error: refuses to overwrite /dev/sda" >&2
		exit 1
	elif [ -b "$DEV" ]
	then
		: ok
	else
		echo "error: not a block device: $DEV" >&2
		exit 1
	fi
fi

$DEBUG && echo "-- unmount partitions --" >&2

TOTALSIZE=0

for P in 1 2 3 4
do
	umount -f ${DEVP}${P} 2>/dev/null
	case "$(getparam $P FORMAT)" in
		none )
			## check if this is the last or only followed by "none"
			## i.e. there can't be "holes" in the partition numbers
			;; # skip
		fat | ext* )
			! $DRYRUN && mkdir -p /media/P${P}
			TOTALSIZE=$(expr "$TOTALSIZE" + "$(getparam $P SIZE)")	# sum up
			;;
	esac
done

ls -l /media/P[1-4]

$DEBUG && echo "-- total size $TOTALSIZE --" >&2

## the following code is roughly
## based on: http://omappedia.org/wiki/SD_Configuration#Script_to_partition.2Fformat_SDCards
## and: http://www.sakoman.com/OMAP/a-script-for-partitioningformatting-a-bootable-sdmicrosd-card.html

$DEBUG && echo "-- clear boot record --" >&2
! $DRYRUN && dd if=/dev/zero of=$DEV bs=1024 count=1024	# clear boot records

$DEBUG && echo "-- partitioning --" >&2
SIZE=$(LC_ALL=C LANGUAGE=C fdisk -c -l "$DEV" | grep Disk | awk '{print $5}')	# make sure fdisk runs in default LANGUAGE
$DEBUG && echo "-- DISK SIZE: $SIZE bytes --" >&2
TOTALSECTORS=$(expr "$SIZE" / 512)
$DEBUG && echo "-- TOTAL SECTORS: $TOTALSECTORS --" >&2
SECTORS=63
HEADS=255
CYLINDERS=$(expr "$TOTALSECTORS" / "$HEADS" / "$SECTORS")
$DEBUG && echo "-- CYLINDERS: $CYLINDERS --" >&2
SECTORSPERCYLINDER=$(expr "$TOTALSECTORS" / "$CYLINDERS")
$DEBUG && echo "-- SECTORS PER CYLINDER: $SECTORSPERCYLINDER --" >&2

{ # run in an anonymous function, not a subprocess
PSTART=128
for P in 1 2 3 4
do # calculate sizes of partitions
	FORMAT=$(getparam $P FORMAT)
	REMAINING=$(expr "$TOTALSECTORS" - "$PSTART")
	THISSIZE=$(getparam $P SIZE)
	if [ "$THISSIZE" = "$TOTALSIZE" ]
	then # last partition
		PSECTORS="$REMAINING"	# take all remaining sectors
	elif [ "$TOTALSIZE" -gt 0 ]
	then # intermediate partition
		PSECTORS=$(expr \( "$REMAINING" '*' "$THISSIZE" \) / "$TOTALSIZE")
#		S1=$PSECTORS
#		echo "S1: $S1" >&2
#		S2=$(expr "$PSTART" + "$S1" + "$SECTORSPERCYLINDER" - 1 )
#		echo "S2: $S2" >&2
#		S3=$(expr "$S2" / "$SECTORSPERCYLINDER" )
#		echo "S3: $S3" >&2
#		PSECTORS=$(expr \( \( "$PSTART" + "$PSECTORS" + "$SECTORSPERCYLINDER" - 1 \) / "$SECTORSPERCYLINDER" \) "*" "$SECTORSPERCYLINDER" - "$PSTART") # round up to end of full cylinder boundary
	else
		PSECTORS=0	# must be a "none"
	fi
#(
#echo "P: $P" >&2
#echo "FORMAT: $FORMAT" >&2
#echo "THISSIZE: $THISSIZE ($TOTALSIZE)" >&2
#echo "SECTORS: $PSTART + $PSECTORS .. $REMAINING" >&2
#) >&2
	case "$FORMAT" in
		none )
			: skip # (how with sfdisk? do we have to read the current partition sizes)
			# this gives the wrong impression that we could define just a partition 3 and none for 1 & 2
			;;
		fat )
			echo "$PSTART,$PSECTORS,0x0C,*"	# FAT partition (bootable)
			TOTALSIZE=$(expr "$TOTALSIZE" - "$THISSIZE")	# this is not exactly correct
			PSTART=$(expr "$PSTART" + "$PSECTORS")
			;;
		ext* )
			echo "$PSTART,$PSECTORS,,-"	# Linux partition
			TOTALSIZE=$(expr "$TOTALSIZE" - "$THISSIZE")	# this is not exactly correct
			PSTART=$(expr "$PSTART" + "$PSECTORS")
			;;
	esac
done
if [ "$TOTALSIZE" != 0 -o "$REMAINING" != 0 ]
	then
	echo "error: error in partition calculation" >&2
	exit 1
fi
} |
if $DRYRUN
then
	cat >&2 # echo to stderr
else
	sfdisk -L --force -D -uS -H "$HEADS" -S "$SECTORS" -C "$CYLINDERS" "$DEV"
fi

/sbin/partprobe "$DEV"

$DEBUG && echo "-- format partitions --" >&2

if ! $DRYRUN
then
for P in 1 2 3 4
do # format partitions
	umount ${DEVP}${P} 2>/dev/null
	case "$(getparam $P FORMAT)" in
		none )
			: skip
			;;
		fat )
			mkfs.vfat -F 32 -n "boot" ${DEVP}${P} &&
			fsck.vfat -y ${DEVP}${P}
			mount ${DEVP}${P} /media/P${P} || exit
			;;
		ext* )
			# FIXME: make different volume names for different rootfs???
			PNAME="rootfs"
			mke2fs -j -L "${PNAME}" ${DEVP}${P} &&
			fsck.ext3 -y ${DEVP}${P}
			mount ${DEVP}${P} /media/P${P} || exit
			;;
	esac
done
fi

df # should have been formatted and mounted now

$DEBUG && echo "-- variables --" >&2
$DEBUG && set >&2

$DEBUG && echo "-- install --" >&2

KERNEL_VERSION=""

for P in 1 2 3 4
do

FORMAT=$(getparam "$P" FORMAT)
if [ "$FORMAT" = "none" -o ! -d /media/P${P} ]
then
	continue	# skip
fi

# location on boot partition is depending on format
[ "$FORMAT" = "fat" ] && BDEST="/media/P${P}" || BDEST="/media/P${P}/boot"

BOOT=$(getparam "$P" BOOT)
ROOTFS=$(getparam "$P" ROOTFS)
KERNEL=$(getparam "$P" KERNEL)
MODULES=$(getparam "$P" MODULES)
DT=$(getparam "$P" DT)
CONFIG=$(getparam "$P" CONFIG)

## FIXME: should also try .tbz and .tgz
## FIXME: and we should be able to unpack some .dd.bz2 or img.bz2

if [ "$ROOTFS" != none ]
then # a rootfs must be installed first so that we can overwrite by a kernel

	$DEBUG && echo "-- fetch rootfs --" >&2
	ls -l /media/P${P}
	# run in a subshell so that we can really redirect ouput
	fetch "$ROOTFS" /dev/fd/1 | ( cd "/media/P${P}" && tar xvjf - )
fi

if [ "$BOOT" != none ]
then
	$DEBUG && echo "-- fetch boot loader --" >&2
	mkdir -p "$BDEST"
	# loading some files may fail since they does not exist for the chosen variant - but we ignore
	fetch "$(dirname "$BOOT")/MLO" "$BDEST/MLO"	# must come first
	fetch "$(dirname "$BOOT")/x-load.flash" "$BDEST/x-load.flash"
	fetch "$BOOT" "$BDEST/u-boot.bin"
	# some x-loaders want u-boot.bin others want u-boot.img (e.g. the OMAP5 MLO)
	cp "$BDEST/u-boot.bin" "$BDEST/u-boot.img"
	fetch "$(dirname "$BOOT")/u-boot.flash" "$BDEST/u-boot.flash"
	fetch "$(dirname "$BOOT")/splash.rgb16z" "$BDEST/splash.rgb16z"
	fetch "$(dirname "$BOOT")/menu.rgb16z" "$BDEST/menu.rgb16z"
	fetch "$(dirname "$BOOT")/boot.scr" "$BDEST/boot.scr"
	fetch "$(dirname "$BOOT")/boot.txt" "$BDEST/boot.txt"
fi

## FIXME: some u-boots want uImage.bin others want uImage.img

if [ "$KERNEL" != none ]
then
	$DEBUG && echo "-- fetch kernel --" >&2
	mkdir -p "$BDEST"
	KDEST="$BDEST/$(basename "$KERNEL")"
	fetch "$KERNEL" "$KDEST"
	fetch "$(dirname "$KERNEL")/bootargs.scr" "$BDEST/bootargs.scr"
	KERNEL_VERSION=$(file "$KDEST")
	KERNEL_VERSION=$(expr "$KERNEL_VERSION" : ".*Linux-\([^,]*\),.*")
	$DEBUG && echo "-- installed $KERNEL_VERSION --" >&2
fi

if [ "$DT" != none ]
then
	$DEBUG && echo "-- fetch device trees --" >&2
	mkdir -p "$BDEST"
	fetch "$DT" /dev/fd/1 | ( cd "$BDEST/" && tar xvjf - )
fi

if [ "$MODULES" != none ]
then
	$DEBUG && echo "-- fetch modules --" >&2
	fetch "$MODULES" /dev/fd/1 | (cd "/media/P${P}/" && tar xvzf -)
	if [ "$KERNEL_VERSION" ] && exists depmod
	then # run depmod on the installed root for the last kernel we have installed
		$DEBUG && echo "-- run depmod $KERNEL_VERSION --" >&2
		depmod -b "/media/P${P}/" "$KERNEL_VERSION"
	fi
fi

if [ "$CONFIG" != none ]
then
	$DEBUG && echo "-- fetch config patches --" >&2
	fetch "$CONFIG" /dev/fd/1 | (cd "/media/P${P}/" && tar xvzf -)
fi

ls -l /media/P[1-4]

done

$DEBUG && echo "-- sync --" >&2

sync

if [ "$DEV" ]
then
	$DEBUG && echo "-- show mounted partitions --" >&2
	df
	$DEBUG && echo "-- unmount --" >&2
	for P in 1 2 3 4
	do
		umount ${DEVP}${P} 2>/dev/null
		rmdir /media/P${P}
	done
	$DEBUG && echo "-- fsck --" >&2
	for P in 1 2 3 4
	do
		fsck -f ${DEVP}${P}
	done
fi

$DEBUG && echo "-- done --" >&2
